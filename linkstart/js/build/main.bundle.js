// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const REVISION = "122dev";
const PCFShadowMap = 1;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AddEquation = 100;
const MinEquation = 103;
const MaxEquation = 104;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const LessEqualDepth = 3;
const MultiplyOperation = 0;
const NoToneMapping = 0;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const LinearFilter = 1006;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const UnsignedShortType = 1012;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedInt248Type = 1020;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const DepthFormat = 1026;
const LoopRepeat = 2201;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const GLSL3 = "300 es";
function EventDispatcher() {}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === undefined) {
            listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
        }
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
                listenerArray.splice(index, 1);
            }
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            const array = listenerArray.slice(0);
            for(let i = 0, l = array.length; i < l; i++){
                array[i].call(this, event);
            }
        }
    }
});
const _lut = [];
for(let i = 0; i < 256; i++){
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
let _seed = 1234567;
const MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        const d0 = Math.random() * 0xffffffff | 0;
        const d1 = Math.random() * 0xffffffff | 0;
        const d2 = Math.random() * 0xffffffff | 0;
        const d3 = Math.random() * 0xffffffff | 0;
        const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + "-" + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + "-" + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + "-" + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + "-" + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
        return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    lerp: function(x, y, t) {
        return (1 - t) * x + t * y;
    },
    smoothstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    seededRandom: function(s) {
        if (s !== undefined) _seed = s % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
        return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch(order){
            case "XYX":
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case "YZY":
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case "ZXZ":
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case "XZX":
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case "YXY":
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case "ZYZ":
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
    }
};
class Vector2 {
    constructor(x = 0, y = 0){
        Object.defineProperty(this, "isVector2", {
            value: true
        });
        this.x = x;
        this.y = y;
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
}
class Matrix3 {
    constructor(){
        Object.defineProperty(this, "isMatrix3", {
            value: true
        });
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1, 
        ];
        if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    getInverse(matrix, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) {
            console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        }
        const me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp;
        const m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i = 0; i < 9; i++){
            if (te[i] !== me[i]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i = 0; i < 9; i++){
            this.elements[i] = array[i + offset];
        }
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
}
let _canvas;
const ImageUtils = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) {
            return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
            canvas = image;
        } else {
            if (_canvas === undefined) {
                _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            }
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
                context.putImageData(image, 0, 0);
            } else {
                context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
            return canvas.toDataURL("image/jpeg", 0.6);
        } else {
            return canvas.toDataURL("image/png");
        }
    }
};
let textureId = 0;
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, "id", {
        value: textureId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.internalFormat = null;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== undefined) {
            return meta.textures[this.uuid];
        }
        const output = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            const image = this.image;
            if (image.uuid === undefined) {
                image.uuid = MathUtils.generateUUID();
            }
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    url = [];
                    for(let i = 0, l = image.length; i < l; i++){
                        url.push(ImageUtils.getDataURL(image[i]));
                    }
                } else {
                    url = ImageUtils.getDataURL(image);
                }
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) {
            meta.textures[this.uuid] = output;
        }
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
            switch(this.wrapS){
                case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                        uv.x = Math.ceil(uv.x) - uv.x;
                    } else {
                        uv.x = uv.x - Math.floor(uv.x);
                    }
                    break;
            }
        }
        if (uv.y < 0 || uv.y > 1) {
            switch(this.wrapT){
                case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                        uv.y = Math.ceil(uv.y) - uv.y;
                    } else {
                        uv.y = uv.y - Math.floor(uv.y);
                    }
                    break;
            }
        }
        if (this.flipY) {
            uv.y = 1 - uv.y;
        }
        return uv;
    }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
class Vector4 {
    constructor(x = 0, y = 0, z = 0, w = 1){
        Object.defineProperty(this, "isVector4", {
            value: true
        });
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        let angle, x, y, z;
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < 0.01 && Math.abs(m13 - m31) < 0.01 && Math.abs(m23 - m32) < 0.01) {
            if (Math.abs(m12 + m21) < 0.1 && Math.abs(m13 + m31) < 0.1 && Math.abs(m23 + m32) < 0.1 && Math.abs(m11 + m22 + m33 - 3) < 0.1) {
                this.set(1, 0, 0, 0);
                return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                if (xx < 0.01) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                if (yy < 0.01) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else {
                if (zz < 0.01) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                }
            }
            this.set(x, y, z, angle);
            return this;
        }
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001) s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
}
function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
function WebGLMultisampleRenderTarget(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function(source) {
        WebGLRenderTarget.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
});
class Quaternion {
    constructor(x = 0, y = 0, z = 0, w = 1){
        Object.defineProperty(this, "isQuaternion", {
            value: true
        });
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    static slerp(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y / 2);
        const s3 = sin(z / 2);
        switch(order){
            case "XYZ":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "YXZ":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case "ZXY":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "ZYX":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case "YZX":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "XZY":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1.0);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s1 = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this._w = (m32 - m23) / s1;
            this._x = 0.25 * s1;
            this._y = (m12 + m21) / s1;
            this._z = (m13 + m31) / s1;
        } else if (m22 > m33) {
            const s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this._w = (m13 - m31) / s2;
            this._x = (m12 + m21) / s2;
            this._y = 0.25 * s2;
            this._z = (m23 + m32) / s2;
        } else {
            const s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this._w = (m21 - m12) / s3;
            this._x = (m13 + m31) / s3;
            this._y = (m23 + m32) / s3;
            this._z = 0.25 * s3;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        let r = vFrom.dot(vTo) + 1;
        if (r < 0.000001) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    inverse() {
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x = this._x, y = this._y, z = this._z, w = this._w;
        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else {
            this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
}
class Vector3 {
    constructor(x = 0, y = 0, z = 0){
        Object.defineProperty(this, "isVector3", {
            value: true
        });
        this.x = x;
        this.y = y;
        this.z = z;
    }
    set(x, y, z) {
        if (z === undefined) z = this.z;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
    }
    applyQuaternion(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        _vector.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector);
    }
    reflect(normal) {
        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        return Math.acos(MathUtils.clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
}
const _vector = new Vector3();
const _quaternion = new Quaternion();
class Box3 {
    constructor(min, max){
        Object.defineProperty(this, "isBox3", {
            value: true
        });
        this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromArray(array) {
        let minX = +Infinity;
        let minY = +Infinity;
        let minZ = +Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i = 0, l = array.length; i < l; i += 3){
            const x = array[i];
            const y = array[i + 1];
            const z = array[i + 2];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromBufferAttribute(attribute) {
        let minX = +Infinity;
        let minY = +Infinity;
        let minZ = +Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i = 0, l = attribute.count; i < l; i++){
            const x = attribute.getX(i);
            const y = attribute.getY(i);
            const z = attribute.getZ(i);
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i = 0, il = points.length; i < il; i++){
            this.expandByPoint(points[i]);
        }
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = +Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .getCenter() target is now required");
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .getSize() target is now required");
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    expandByObject(object) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
            }
            _box.copy(geometry.boundingBox);
            _box.applyMatrix4(object.matrixWorld);
            this.union(_box);
        }
        const children = object.children;
        for(let i = 0, l = children.length; i < l; i++){
            this.expandByObject(children[i]);
        }
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .getParameter() target is now required");
            target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector1);
        return _vector1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
        if (this.isEmpty()) {
            return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0.subVectors(triangle.a, _center);
        _v1.subVectors(triangle.b, _center);
        _v2.subVectors(triangle.c, _center);
        _f0.subVectors(_v1, _v0);
        _f1.subVectors(_v2, _v1);
        _f2.subVectors(_v0, _v2);
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0, 
        ];
        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
            return false;
        }
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
            return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v0, _v1, _v2, _extents);
    }
    clampPoint(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .clampPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
        if (target === undefined) {
            console.error("THREE.Box3: .getBoundingSphere() target is now required");
        }
        this.getCenter(target.center);
        target.radius = this.getSize(_vector1).length() * 0.5;
        return target;
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    applyMatrix4(matrix) {
        if (this.isEmpty()) return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i = 0, j = axes.length - 3; i <= j; i += 3){
        _testAxis.fromArray(axes, i);
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
            return false;
        }
    }
    return true;
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(), 
];
const _vector1 = new Vector3();
const _box = new Box3();
const _v0 = new Vector3();
const _v1 = new Vector3();
const _v2 = new Vector3();
const _f0 = new Vector3();
const _f1 = new Vector3();
const _f2 = new Vector3();
const _center = new Vector3();
const _extents = new Vector3();
const _triangleNormal = new Vector3();
const _testAxis = new Vector3();
const _box1 = new Box3();
class Sphere {
    constructor(center, radius){
        this.center = center !== undefined ? center : new Vector3();
        this.radius = radius !== undefined ? radius : -1;
    }
    set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    }
    setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
        } else {
            _box1.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for(let i = 0, il = points.length; i < il; i++){
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
        return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn("THREE.Sphere: .clampPoint() target is now required");
            target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    }
    getBoundingBox(target) {
        if (target === undefined) {
            console.warn("THREE.Sphere: .getBoundingBox() target is now required");
            target = new Box3();
        }
        if (this.isEmpty()) {
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    }
    applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    }
    translate(offset) {
        this.center.add(offset);
        return this;
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
}
const _vector2 = new Vector3();
const _segCenter = new Vector3();
const _segDir = new Vector3();
const _diff = new Vector3();
const _edge1 = new Vector3();
const _edge2 = new Vector3();
const _normal = new Vector3();
class Ray {
    constructor(origin, direction){
        this.origin = origin !== undefined ? origin : new Vector3();
        this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
    }
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        if (target === undefined) {
            console.warn("THREE.Ray: .at() target is now required");
            target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, _vector2));
        return this;
    }
    closestPointToPoint(point, target) {
        if (target === undefined) {
            console.warn("THREE.Ray: .closestPointToPoint() target is now required");
            target = new Vector3();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
            return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = _vector2.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
        }
        _vector2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector2.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        _vector2.subVectors(sphere.center, this.origin);
        const tca = _vector2.dot(this.direction);
        const d2 = _vector2.dot(_vector2) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0) return null;
        if (t0 < 0) return this.at(t1, target);
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
                return 0;
            }
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) {
            return null;
        }
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
            return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
            return true;
        }
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, _vector2) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal);
        let sign;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign = 1;
        } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        } else {
            return null;
        }
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
            return null;
        }
        const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
            return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
            return null;
        }
        const QdN = -sign * _diff.dot(_normal);
        if (QdN < 0) {
            return null;
        }
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
}
class Matrix4 {
    constructor(){
        Object.defineProperty(this, "isMatrix4", {
            value: true
        });
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1, 
        ];
        if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v11.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v11.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v11.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === "ZXY") {
            const ce1 = c * e, cf1 = c * f, de1 = d * e, df1 = d * f;
            te[0] = ce1 - df1 * b;
            te[4] = -a * f;
            te[8] = de1 + cf1 * b;
            te[1] = cf1 + de1 * b;
            te[5] = a * e;
            te[9] = df1 - ce1 * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === "ZYX") {
            const ae1 = a * e, af1 = a * f, be1 = b * e, bf1 = b * f;
            te[0] = c * e;
            te[4] = be1 * d - af1;
            te[8] = ae1 * d + bf1;
            te[1] = c * f;
            te[5] = bf1 * d + ae1;
            te[9] = af1 * d - be1;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
            const ac1 = a * c, ad1 = a * d, bc1 = b * c, bd1 = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac1 * f + bd1;
            te[5] = a * e;
            te[9] = ad1 * f - bc1;
            te[2] = bc1 * f - ad1;
            te[6] = b * e;
            te[10] = bd1 * f + ac1;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
            _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
                _z.x += 0.0001;
            } else {
                _z.z += 0.0001;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    getInverse(m, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) {
            console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        }
        const te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v11.set(te[0], te[1], te[2]).length();
        const sy = _v11.set(te[4], te[5], te[6]).length();
        const sz = _v11.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1.0 / (right - left);
        const h = 1.0 / (top - bottom);
        const p = 1.0 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i = 0; i < 16; i++){
            if (te[i] !== me[i]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i = 0; i < 16; i++){
            this.elements[i] = array[i + offset];
        }
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
}
const _v11 = new Vector3();
const _m1 = new Matrix4();
const _zero = new Vector3(0, 0, 0);
const _one = new Vector3(1, 1, 1);
const _x = new Vector3();
const _y = new Vector3();
const _z = new Vector3();
class Euler {
    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder){
        Object.defineProperty(this, "isEuler", {
            value: true
        });
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order, update) {
        const clamp = MathUtils.clamp;
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case "XYZ":
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case "YXZ":
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case "ZXY":
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case "ZYX":
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case "YZX":
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case "XZY":
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
        _quaternion1.setFromEuler(this);
        return this.setFromQuaternion(_quaternion1, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
        } else {
            return new Vector3(this._x, this._y, this._z);
        }
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
}
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = [
    "XYZ",
    "YZX",
    "ZXY",
    "XZY",
    "YXZ",
    "ZYX"
];
const _matrix = new Matrix4();
const _quaternion1 = new Quaternion();
class Layers {
    constructor(){
        this.mask = 1 | 0;
    }
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = 0xffffffff | 0;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
}
let _object3DId = 0;
const _v12 = new Vector3();
const _q1 = new Quaternion();
const _m11 = new Matrix4();
const _target = new Vector3();
const _position = new Vector3();
const _scale = new Vector3();
const _quaternion2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {
    type: "added"
};
const _removedEvent = {
    type: "removed"
};
function Object3D() {
    Object.defineProperty(this, "id", {
        value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix4()
        },
        normalMatrix: {
            value: new Matrix3()
        }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {},
    onAfterRender: function() {},
    applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    },
    rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
        _v12.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v12.multiplyScalar(distance));
        return this;
    },
    translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
        return vector.applyMatrix4(_m11.getInverse(this.matrixWorld));
    },
    lookAt: function(x, y, z) {
        if (x.isVector3) {
            _target.copy(x);
        } else {
            _target.set(x, y, z);
        }
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
            _m11.lookAt(_position, _target, this.up);
        } else {
            _m11.lookAt(_target, _position, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m11);
        if (parent) {
            _m11.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m11);
            this.quaternion.premultiply(_q1.inverse());
        }
    },
    add: function(object) {
        if (arguments.length > 1) {
            for(let i = 0; i < arguments.length; i++){
                this.add(arguments[i]);
            }
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) {
                object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(let i = 0; i < arguments.length; i++){
                this.remove(arguments[i]);
            }
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    },
    removeAll: function() {
        for(let i = 0; i < this.children.length; i++){
            const object = this.children[i];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
    },
    attach: function(object) {
        this.updateWorldMatrix(true, false);
        _m11.getInverse(this.matrixWorld);
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m11.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m11);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for(let i = 0, l = this.children.length; i < l; i++){
            const child = this.children[i];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) {
                return object;
            }
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldPosition() target is now required");
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
            target = new Quaternion();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
    },
    getWorldScale: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldScale() target is now required");
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position, _quaternion2, target);
        return target;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldDirection() target is now required");
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {},
    traverse: function(callback) {
        callback(this);
        const children = this.children;
        for(let i = 0, l = children.length; i < l; i++){
            children[i].traverse(callback);
        }
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i = 0, l = children.length; i < l; i++){
            children[i].traverseVisible(callback);
        }
    },
    traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        const children = this.children;
        for(let i = 0, l = children.length; i < l; i++){
            children[i].updateMatrixWorld(force);
        }
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
        } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
            const children = this.children;
            for(let i = 0, l = children.length; i < l; i++){
                children[i].updateWorldMatrix(false, true);
            }
        }
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === "string";
        const output = {};
        if (isRootObject) {
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            };
            output.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "") object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        function serialize(library, element) {
            if (library[element.uuid] === undefined) {
                library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) {
                    for(let i = 0, l = shapes.length; i < l; i++){
                        const shape = shapes[i];
                        serialize(meta.shapes, shape);
                    }
                } else {
                    serialize(meta.shapes, shapes);
                }
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i1 = 0, l1 = this.material.length; i1 < l1; i1++){
                    uuids.push(serialize(meta.materials, this.material[i1]));
                }
                object.material = uuids;
            } else {
                object.material = serialize(meta.materials, this.material);
            }
        }
        if (this.children.length > 0) {
            object.children = [];
            for(let i2 = 0; i2 < this.children.length; i2++){
                object.children.push(this.children[i2].toJSON(meta).object);
            }
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes1 = extractFromCache(meta.shapes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes1.length > 0) output.shapes = shapes1;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
        if (recursive === undefined) recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
            for(let i = 0; i < source.children.length; i++){
                const child = source.children[i];
                this.add(child.clone());
            }
        }
        return this;
    }
});
const _vector11 = new Vector3();
const _vector21 = new Vector3();
const _normalMatrix = new Matrix3();
class Plane {
    constructor(normal, constant){
        Object.defineProperty(this, "isPlane", {
            value: true
        });
        this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
        this.constant = constant !== undefined ? constant : 0;
    }
    set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    }
    setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    }
    setFromCoplanarPoints(a, b, c) {
        const normal = _vector11.subVectors(c, b).cross(_vector21.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    }
    normalize() {
        const inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    }
    negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
        if (target === undefined) {
            console.warn("THREE.Plane: .projectPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
        if (target === undefined) {
            console.warn("THREE.Plane: .intersectLine() target is now required");
            target = new Vector3();
        }
        const direction = line.delta(_vector11);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
                return target.copy(line.start);
            }
            return undefined;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
            return undefined;
        }
        return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
        return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
        if (target === undefined) {
            console.warn("THREE.Plane: .coplanarPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector11).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
    }
    translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
}
const _v01 = new Vector3();
const _v13 = new Vector3();
const _v21 = new Vector3();
const _v3 = new Vector3();
const _vab = new Vector3();
const _vac = new Vector3();
const _vbc = new Vector3();
const _vap = new Vector3();
const _vbp = new Vector3();
const _vcp = new Vector3();
class Triangle {
    constructor(a, b, c){
        this.a = a !== undefined ? a : new Vector3();
        this.b = b !== undefined ? b : new Vector3();
        this.c = c !== undefined ? c : new Vector3();
    }
    static getNormal(a, b, c, target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .getNormal() target is now required");
            target = new Vector3();
        }
        target.subVectors(c, b);
        _v01.subVectors(a, b);
        target.cross(_v01);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
    }
    static getBarycoord(point, a, b, c, target) {
        _v01.subVectors(c, a);
        _v13.subVectors(b, a);
        _v21.subVectors(point, a);
        const dot00 = _v01.dot(_v01);
        const dot01 = _v01.dot(_v13);
        const dot02 = _v01.dot(_v21);
        const dot11 = _v13.dot(_v13);
        const dot12 = _v13.dot(_v21);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === undefined) {
            console.warn("THREE.Triangle: .getBarycoord() target is now required");
            target = new Vector3();
        }
        if (denom === 0) {
            return target.set(-2, -1, -1);
        }
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3.x);
        target.addScaledVector(uv2, _v3.y);
        target.addScaledVector(uv3, _v3.z);
        return target;
    }
    static isFrontFacing(a, b, c, direction) {
        _v01.subVectors(c, b);
        _v13.subVectors(a, b);
        return _v01.cross(_v13).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    }
    getArea() {
        _v01.subVectors(this.c, this.b);
        _v13.subVectors(this.a, this.b);
        return _v01.cross(_v13).length() * 0.5;
    }
    getMidpoint(target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .getMidpoint() target is now required");
            target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .getPlane() target is now required");
            target = new Plane();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
            target = new Vector3();
        }
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
        }
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc, w);
        }
        const denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
}
const _colorKeywords = {
    "aliceblue": 0xF0F8FF,
    "antiquewhite": 0xFAEBD7,
    "aqua": 0x00FFFF,
    "aquamarine": 0x7FFFD4,
    "azure": 0xF0FFFF,
    "beige": 0xF5F5DC,
    "bisque": 0xFFE4C4,
    "black": 0x000000,
    "blanchedalmond": 0xFFEBCD,
    "blue": 0x0000FF,
    "blueviolet": 0x8A2BE2,
    "brown": 0xA52A2A,
    "burlywood": 0xDEB887,
    "cadetblue": 0x5F9EA0,
    "chartreuse": 0x7FFF00,
    "chocolate": 0xD2691E,
    "coral": 0xFF7F50,
    "cornflowerblue": 0x6495ED,
    "cornsilk": 0xFFF8DC,
    "crimson": 0xDC143C,
    "cyan": 0x00FFFF,
    "darkblue": 0x00008B,
    "darkcyan": 0x008B8B,
    "darkgoldenrod": 0xB8860B,
    "darkgray": 0xA9A9A9,
    "darkgreen": 0x006400,
    "darkgrey": 0xA9A9A9,
    "darkkhaki": 0xBDB76B,
    "darkmagenta": 0x8B008B,
    "darkolivegreen": 0x556B2F,
    "darkorange": 0xFF8C00,
    "darkorchid": 0x9932CC,
    "darkred": 0x8B0000,
    "darksalmon": 0xE9967A,
    "darkseagreen": 0x8FBC8F,
    "darkslateblue": 0x483D8B,
    "darkslategray": 0x2F4F4F,
    "darkslategrey": 0x2F4F4F,
    "darkturquoise": 0x00CED1,
    "darkviolet": 0x9400D3,
    "deeppink": 0xFF1493,
    "deepskyblue": 0x00BFFF,
    "dimgray": 0x696969,
    "dimgrey": 0x696969,
    "dodgerblue": 0x1E90FF,
    "firebrick": 0xB22222,
    "floralwhite": 0xFFFAF0,
    "forestgreen": 0x228B22,
    "fuchsia": 0xFF00FF,
    "gainsboro": 0xDCDCDC,
    "ghostwhite": 0xF8F8FF,
    "gold": 0xFFD700,
    "goldenrod": 0xDAA520,
    "gray": 0x808080,
    "green": 0x008000,
    "greenyellow": 0xADFF2F,
    "grey": 0x808080,
    "honeydew": 0xF0FFF0,
    "hotpink": 0xFF69B4,
    "indianred": 0xCD5C5C,
    "indigo": 0x4B0082,
    "ivory": 0xFFFFF0,
    "khaki": 0xF0E68C,
    "lavender": 0xE6E6FA,
    "lavenderblush": 0xFFF0F5,
    "lawngreen": 0x7CFC00,
    "lemonchiffon": 0xFFFACD,
    "lightblue": 0xADD8E6,
    "lightcoral": 0xF08080,
    "lightcyan": 0xE0FFFF,
    "lightgoldenrodyellow": 0xFAFAD2,
    "lightgray": 0xD3D3D3,
    "lightgreen": 0x90EE90,
    "lightgrey": 0xD3D3D3,
    "lightpink": 0xFFB6C1,
    "lightsalmon": 0xFFA07A,
    "lightseagreen": 0x20B2AA,
    "lightskyblue": 0x87CEFA,
    "lightslategray": 0x778899,
    "lightslategrey": 0x778899,
    "lightsteelblue": 0xB0C4DE,
    "lightyellow": 0xFFFFE0,
    "lime": 0x00FF00,
    "limegreen": 0x32CD32,
    "linen": 0xFAF0E6,
    "magenta": 0xFF00FF,
    "maroon": 0x800000,
    "mediumaquamarine": 0x66CDAA,
    "mediumblue": 0x0000CD,
    "mediumorchid": 0xBA55D3,
    "mediumpurple": 0x9370DB,
    "mediumseagreen": 0x3CB371,
    "mediumslateblue": 0x7B68EE,
    "mediumspringgreen": 0x00FA9A,
    "mediumturquoise": 0x48D1CC,
    "mediumvioletred": 0xC71585,
    "midnightblue": 0x191970,
    "mintcream": 0xF5FFFA,
    "mistyrose": 0xFFE4E1,
    "moccasin": 0xFFE4B5,
    "navajowhite": 0xFFDEAD,
    "navy": 0x000080,
    "oldlace": 0xFDF5E6,
    "olive": 0x808000,
    "olivedrab": 0x6B8E23,
    "orange": 0xFFA500,
    "orangered": 0xFF4500,
    "orchid": 0xDA70D6,
    "palegoldenrod": 0xEEE8AA,
    "palegreen": 0x98FB98,
    "paleturquoise": 0xAFEEEE,
    "palevioletred": 0xDB7093,
    "papayawhip": 0xFFEFD5,
    "peachpuff": 0xFFDAB9,
    "peru": 0xCD853F,
    "pink": 0xFFC0CB,
    "plum": 0xDDA0DD,
    "powderblue": 0xB0E0E6,
    "purple": 0x800080,
    "rebeccapurple": 0x663399,
    "red": 0xFF0000,
    "rosybrown": 0xBC8F8F,
    "royalblue": 0x4169E1,
    "saddlebrown": 0x8B4513,
    "salmon": 0xFA8072,
    "sandybrown": 0xF4A460,
    "seagreen": 0x2E8B57,
    "seashell": 0xFFF5EE,
    "sienna": 0xA0522D,
    "silver": 0xC0C0C0,
    "skyblue": 0x87CEEB,
    "slateblue": 0x6A5ACD,
    "slategray": 0x708090,
    "slategrey": 0x708090,
    "snow": 0xFFFAFA,
    "springgreen": 0x00FF7F,
    "steelblue": 0x4682B4,
    "tan": 0xD2B48C,
    "teal": 0x008080,
    "thistle": 0xD8BFD8,
    "tomato": 0xFF6347,
    "turquoise": 0x40E0D0,
    "violet": 0xEE82EE,
    "wheat": 0xF5DEB3,
    "white": 0xFFFFFF,
    "whitesmoke": 0xF5F5F5,
    "yellow": 0xFFFF00,
    "yellowgreen": 0x9ACD32
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
class Color {
    constructor(r, g, b){
        Object.defineProperty(this, "isColor", {
            value: true
        });
        if (g === undefined && b === undefined) {
            return this.set(r);
        }
        return this.setRGB(r, g, b);
    }
    set(value) {
        if (value && value.isColor) {
            this.copy(value);
        } else if (typeof value === "number") {
            this.setHex(value);
        } else if (typeof value === "string") {
            this.setStyle(value);
        }
        return this;
    }
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    }
    setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    }
    setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    }
    setHSL(h, s, l) {
        h = MathUtils.euclideanModulo(h, 1);
        s = MathUtils.clamp(s, 0, 1);
        l = MathUtils.clamp(l, 0, 1);
        if (s === 0) {
            this.r = this.g = this.b = l;
        } else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    }
    setStyle(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) {
                console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case "rgb":
                case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[5]);
                        return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[5]);
                        return this;
                    }
                    break;
                case "hsl":
                case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) {
            return this.setColorName(style);
        }
        return this;
    }
    setColorName(style) {
        const hex = _colorKeywords[style];
        if (hex !== undefined) {
            this.setHex(hex);
        } else {
            console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    copyGammaToLinear(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    }
    copyLinearToGamma(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2.0;
        const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    }
    convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    }
    convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    }
    copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
    }
    copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
    }
    convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
    }
    convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
    }
    getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
        if (target === undefined) {
            console.warn("THREE.Color: .getHSL() target is now required");
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        const r = this.r, g = this.g, b = this.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2.0;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    }
    getStyle() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    }
    offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    }
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    }
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    }
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    }
    sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    }
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    }
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    }
    lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    }
    lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
        const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
        const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    }
    toJSON() {
        return this.getHex();
    }
}
Color.NAMES = _colorKeywords;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class Face3 {
    constructor(a, b, c, normal, color, materialIndex){
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = normal && normal.isVector3 ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = color && color.isColor ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i = 0, il = source.vertexNormals.length; i < il; i++){
            this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for(let i1 = 0, il1 = source.vertexColors.length; i1 < il1; i1++){
            this.vertexColors[i1] = source.vertexColors[i1].clone();
        }
        return this;
    }
}
let materialId = 0;
function Material() {
    Object.defineProperty(this, "id", {
        value: materialId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 0xff;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 0xff;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {},
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            if (key === "shading") {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) {
                currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
                currentValue.copy(newValue);
            } else {
                this[key] = newValue;
            }
        }
    },
    toJSON: function(meta) {
        const isRoot = meta === undefined || typeof meta === "string";
        if (isRoot) {
            meta = {
                textures: {},
                images: {}
            };
        }
        const data = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) {
            data.emissive = this.emissive.getHex();
        }
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) {
            data.emissiveIntensity = this.emissiveIntensity;
        }
        if (this.specular && this.specular.isColor) {
            data.specular = this.specular.getHex();
        }
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) {
            data.clearcoatRoughness = this.clearcoatRoughness;
        }
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) {
            data.matcap = this.matcap.toJSON(meta).uuid;
        }
        if (this.alphaMap && this.alphaMap.isTexture) {
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        }
        if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
        }
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) {
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        }
        if (this.metalnessMap && this.metalnessMap.isTexture) {
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        }
        if (this.emissiveMap && this.emissiveMap.isTexture) {
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        }
        if (this.specularMap && this.specularMap.isTexture) {
            data.specularMap = this.specularMap.toJSON(meta).uuid;
        }
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity;
            data.refractionRatio = this.refractionRatio;
            if (this.combine !== undefined) data.combine = this.combine;
            if (this.envMapIntensity !== undefined) {
                data.envMapIntensity = this.envMapIntensity;
            }
        }
        if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.size !== undefined) data.size = this.size;
        if (this.sizeAttenuation !== undefined) {
            data.sizeAttenuation = this.sizeAttenuation;
        }
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) {
            data.polygonOffsetFactor = this.polygonOffsetFactor;
        }
        if (this.polygonOffsetUnits !== 0) {
            data.polygonOffsetUnits = this.polygonOffsetUnits;
        }
        if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) {
            data.premultipliedAlpha = this.premultipliedAlpha;
        }
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) {
            data.wireframeLinewidth = this.wireframeLinewidth;
        }
        if (this.wireframeLinecap !== "round") {
            data.wireframeLinecap = this.wireframeLinecap;
        }
        if (this.wireframeLinejoin !== "round") {
            data.wireframeLinejoin = this.wireframeLinejoin;
        }
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.morphNormals === true) data.morphNormals = true;
        if (this.skinning === true) data.skinning = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i = 0; i !== n; ++i){
                dstPlanes[i] = srcPlanes[i].clone();
            }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
const _vector3 = new Vector3();
const _vector22 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {},
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i = 0, l = this.itemSize; i < l; i++){
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for(let i = 0, l = colors.length; i < l; i++){
            let color = colors[i];
            if (color === undefined) {
                console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i = 0, l = vectors.length; i < l; i++){
            let vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i = 0, l = vectors.length; i < l; i++){
            let vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i = 0, l = vectors.length; i < l; i++){
            let vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    applyMatrix3: function(m) {
        if (this.itemSize === 2) {
            for(let i = 0, l = this.count; i < l; i++){
                _vector22.fromBufferAttribute(this, i);
                _vector22.applyMatrix3(m);
                this.setXY(i, _vector22.x, _vector22.y);
            }
        } else if (this.itemSize === 3) {
            for(let i1 = 0, l1 = this.count; i1 < l1; i1++){
                _vector3.fromBufferAttribute(this, i1);
                _vector3.applyMatrix3(m);
                this.setXYZ(i1, _vector3.x, _vector3.y, _vector3.z);
            }
        }
        return this;
    },
    applyMatrix4: function(m) {
        for(let i = 0, l = this.count; i < l; i++){
            _vector3.x = this.getX(i);
            _vector3.y = this.getY(i);
            _vector3.z = this.getZ(i);
            _vector3.applyMatrix4(m);
            this.setXYZ(i, _vector3.x, _vector3.y, _vector3.z);
        }
        return this;
    },
    applyNormalMatrix: function(m) {
        for(let i = 0, l = this.count; i < l; i++){
            _vector3.x = this.getX(i);
            _vector3.y = this.getY(i);
            _vector3.z = this.getZ(i);
            _vector3.applyNormalMatrix(m);
            this.setXYZ(i, _vector3.x, _vector3.y, _vector3.z);
        }
        return this;
    },
    transformDirection: function(m) {
        for(let i = 0, l = this.count; i < l; i++){
            _vector3.x = this.getX(i);
            _vector3.y = this.getY(i);
            _vector3.z = this.getZ(i);
            _vector3.transformDirection(m);
            this.setXYZ(i, _vector3.x, _vector3.y, _vector3.z);
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    getX: function(index) {
        return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    },
    getY: function(index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    },
    getZ: function(index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    },
    getW: function(index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    },
    setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
        return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
    }
});
function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
class DirectGeometry {
    constructor(){
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    computeGroups(geometry) {
        const groups = [];
        let group, i;
        let materialIndex = undefined;
        const faces = geometry.faces;
        for(i = 0; i < faces.length; i++){
            const face = faces[i];
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== undefined) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };
            }
        }
        if (group !== undefined) {
            group.count = i * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    }
    fromGeometry(geometry) {
        const faces = geometry.faces;
        const vertices = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(let i = 0; i < morphTargetsLength; i++){
                morphTargetsPosition[i] = {
                    name: morphTargets[i].name,
                    data: []
                };
            }
            this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(let i1 = 0; i1 < morphNormalsLength; i1++){
                morphTargetsNormal[i1] = {
                    name: morphNormals[i1].name,
                    data: []
                };
            }
            this.morphTargets.normal = morphTargetsNormal;
        }
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices.length;
        const hasSkinWeights = skinWeights.length === vertices.length;
        if (vertices.length > 0 && faces.length === 0) {
            console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        }
        for(let i2 = 0; i2 < faces.length; i2++){
            const face = faces[i2];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            } else {
                const normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            const vertexColors = face.vertexColors;
            if (vertexColors.length === 3) {
                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            } else {
                const color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                const vertexUvs = faceVertexUvs[0][i2];
                if (vertexUvs !== undefined) {
                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            if (hasFaceVertexUv2 === true) {
                const vertexUvs1 = faceVertexUvs[1][i2];
                if (vertexUvs1 !== undefined) {
                    this.uvs2.push(vertexUvs1[0], vertexUvs1[1], vertexUvs1[2]);
                } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            for(let j = 0; j < morphTargetsLength; j++){
                const morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(let j1 = 0; j1 < morphNormalsLength; j1++){
                const morphNormal = morphNormals[j1].vertexNormals[i2];
                morphTargetsNormal[j1].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            if (hasSkinIndices) {
                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            }
            if (hasSkinWeights) {
                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
    }
}
function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    let max = array[0];
    for(let i = 1, l = array.length; i < l; ++i){
        if (array[i] > max) max = array[i];
    }
    return max;
}
let _bufferGeometryId = 1;
const _m12 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector4 = new Vector3();
function BufferGeometry() {
    Object.defineProperty(this, "id", {
        value: _bufferGeometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index) {
        if (Array.isArray(index)) {
            this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        } else {
            this.index = index;
        }
        return this;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    },
    deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function(start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== undefined) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        return this;
    },
    rotateX: function(angle) {
        _m12.makeRotationX(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateY: function(angle) {
        _m12.makeRotationY(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateZ: function(angle) {
        _m12.makeRotationZ(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    translate: function(x, y, z) {
        _m12.makeTranslation(x, y, z);
        this.applyMatrix4(_m12);
        return this;
    },
    scale: function(x, y, z) {
        _m12.makeScale(x, y, z);
        this.applyMatrix4(_m12);
        return this;
    },
    lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    },
    setFromObject: function(object) {
        const geometry = object.geometry;
        if (object.isPoints || object.isLine) {
            const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
            const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
            this.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
            this.setAttribute("color", colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                this.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
        } else if (object.isMesh) {
            if (geometry && geometry.isGeometry) {
                this.fromGeometry(geometry);
            }
        }
        return this;
    },
    setFromPoints: function(points) {
        const position = [];
        for(let i = 0, l = points.length; i < l; i++){
            const point = points[i];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
    },
    updateFromObject: function(object) {
        let geometry = object.geometry;
        if (object.isMesh) {
            let direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) {
                return this.fromGeometry(geometry);
            }
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
            const attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            const attribute1 = this.attributes.normal;
            if (attribute1 !== undefined) {
                attribute1.copyVector3sArray(geometry.normals);
                attribute1.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            const attribute2 = this.attributes.color;
            if (attribute2 !== undefined) {
                attribute2.copyColorsArray(geometry.colors);
                attribute2.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            const attribute3 = this.attributes.uv;
            if (attribute3 !== undefined) {
                attribute3.copyVector2sArray(geometry.uvs);
                attribute3.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            const attribute4 = this.attributes.lineDistance;
            if (attribute4 !== undefined) {
                attribute4.copyArray(geometry.lineDistances);
                attribute4.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
        const positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            const normals = new Float32Array(geometry.normals.length * 3);
            this.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            const colors = new Float32Array(geometry.colors.length * 3);
            this.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            const uvs = new Float32Array(geometry.uvs.length * 2);
            this.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            const uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        this.groups = geometry.groups;
        for(const name in geometry.morphTargets){
            const array = [];
            const morphTargets = geometry.morphTargets[name];
            for(let i = 0, l = morphTargets.length; i < l; i++){
                const morphTarget = morphTargets[i];
                const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                attribute.name = morphTarget.name;
                array.push(attribute.copyVector3sArray(morphTarget.data));
            }
            this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
            const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
            this.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
            this.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
            return;
        }
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
                for(let i = 0, il = morphAttributesPosition.length; i < il; i++){
                    const morphAttribute = morphAttributesPosition[i];
                    _box2.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                        _vector4.addVectors(this.boundingBox.min, _box2.min);
                        this.boundingBox.expandByPoint(_vector4);
                        _vector4.addVectors(this.boundingBox.max, _box2.max);
                        this.boundingBox.expandByPoint(_vector4);
                    } else {
                        this.boundingBox.expandByPoint(_box2.min);
                        this.boundingBox.expandByPoint(_box2.max);
                    }
                }
            }
        } else {
            this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
        }
        if (position) {
            const center = this.boundingSphere.center;
            _box2.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
                for(let i = 0, il = morphAttributesPosition.length; i < il; i++){
                    const morphAttribute = morphAttributesPosition[i];
                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                        _vector4.addVectors(_box2.min, _boxMorphTargets.min);
                        _box2.expandByPoint(_vector4);
                        _vector4.addVectors(_box2.max, _boxMorphTargets.max);
                        _box2.expandByPoint(_vector4);
                    } else {
                        _box2.expandByPoint(_boxMorphTargets.min);
                        _box2.expandByPoint(_boxMorphTargets.max);
                    }
                }
            }
            _box2.getCenter(center);
            let maxRadiusSq = 0;
            for(let i1 = 0, il1 = position.count; i1 < il1; i1++){
                _vector4.fromBufferAttribute(position, i1);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector4));
            }
            if (morphAttributesPosition) {
                for(let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++){
                    const morphAttribute1 = morphAttributesPosition[i2];
                    const morphTargetsRelative = this.morphTargetsRelative;
                    for(let j = 0, jl = morphAttribute1.count; j < jl; j++){
                        _vector4.fromBufferAttribute(morphAttribute1, j);
                        if (morphTargetsRelative) {
                            _offset.fromBufferAttribute(position, j);
                            _vector4.add(_offset);
                        }
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector4));
                    }
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
    },
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        const index = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute("normal", normalAttribute);
            } else {
                for(let i = 0, il = normalAttribute.count; i < il; i++){
                    normalAttribute.setXYZ(i, 0, 0, 0);
                }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            if (index) {
                for(let i1 = 0, il1 = index.count; i1 < il1; i1 += 3){
                    const vA = index.getX(i1 + 0);
                    const vB = index.getX(i1 + 1);
                    const vC = index.getX(i1 + 2);
                    pA.fromBufferAttribute(positionAttribute, vA);
                    pB.fromBufferAttribute(positionAttribute, vB);
                    pC.fromBufferAttribute(positionAttribute, vC);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    nA.fromBufferAttribute(normalAttribute, vA);
                    nB.fromBufferAttribute(normalAttribute, vB);
                    nC.fromBufferAttribute(normalAttribute, vC);
                    nA.add(cb);
                    nB.add(cb);
                    nC.add(cb);
                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                }
            } else {
                for(let i2 = 0, il2 = positionAttribute.count; i2 < il2; i2 += 3){
                    pA.fromBufferAttribute(positionAttribute, i2 + 0);
                    pB.fromBufferAttribute(positionAttribute, i2 + 1);
                    pC.fromBufferAttribute(positionAttribute, i2 + 2);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
                }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. " + "Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i = 0, j = attributeOffset; i < length; i++, j++){
                attributeArray1[j] = attributeArray2[i];
            }
        }
        return this;
    },
    normalizeNormals: function() {
        const normals = this.attributes.normal;
        for(let i = 0, il = normals.count; i < il; i++){
            _vector4.fromBufferAttribute(normals, i);
            _vector4.normalize();
            normals.setXYZ(i, _vector4.x, _vector4.y, _vector4.z);
        }
    },
    toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices.length * itemSize);
            let index = 0, index2 = 0;
            for(let i = 0, l = indices.length; i < l; i++){
                index = indices[i] * itemSize;
                for(let j = 0; j < itemSize; j++){
                    array2[index2++] = array[index++];
                }
            }
            return new BufferAttribute(array2, itemSize, normalized);
        }
        if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
            return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1];
            for(let i = 0, il = morphAttribute.length; i < il; i++){
                const attribute1 = morphAttribute[i];
                const newAttribute1 = convertBufferAttribute(attribute1, indices);
                morphArray.push(newAttribute1);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for(let i1 = 0, l = groups.length; i1 < l; i1++){
            const group = groups[i1];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters){
                if (parameters[key] !== undefined) data[key] = parameters[key];
            }
            return data;
        }
        data.data = {
            attributes: {}
        };
        const index = this.index;
        if (index !== null) {
            data.data.index = {
                type: index.array.constructor.name,
                array: Array.prototype.slice.call(index.array)
            };
        }
        const attributes = this.attributes;
        for(const key1 in attributes){
            const attribute = attributes[key1];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== "") attributeData.name = attribute.name;
            data.data.attributes[key1] = attributeData;
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for(const key2 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key2];
            const array = [];
            for(let i = 0, il = attributeArray.length; i < il; i++){
                const attribute1 = attributeArray[i];
                const attributeData1 = attribute1.toJSON(data.data);
                if (attribute1.name !== "") attributeData1.name = attribute1.name;
                array.push(attributeData1);
            }
            if (array.length > 0) {
                morphAttributes[key2] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };
        }
        return data;
    },
    clone: function() {
        return new BufferGeometry().copy(this);
    },
    copy: function(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index = source.index;
        if (index !== null) {
            this.setIndex(index.clone(data));
        }
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for(const name1 in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name1];
            for(let i = 0, l = morphAttribute.length; i < l; i++){
                array.push(morphAttribute[i].clone(data));
            }
            this.morphAttributes[name1] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for(let i1 = 0, l1 = groups.length; i1 < l1; i1++){
            const group = groups[i1];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial();
    this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== undefined) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== undefined) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) {
                console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
        }
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        if (geometry.boundingBox !== null) {
            if (_ray.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                if (Array.isArray(material)) {
                    for(let i = 0, il = groups.length; i < il; i++){
                        const group = groups[i];
                        const groupMaterial = material[group.materialIndex];
                        const start = Math.max(group.start, drawRange.start);
                        const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                        for(let j = start, jl = end; j < jl; j += 3){
                            const a = index.getX(j);
                            const b = index.getX(j + 1);
                            const c = index.getX(j + 2);
                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3);
                                intersection.face.materialIndex = group.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else {
                    const start1 = Math.max(0, drawRange.start);
                    const end1 = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i1 = start1, il1 = end1; i1 < il1; i1 += 3){
                        const a1 = index.getX(i1);
                        const b1 = index.getX(i1 + 1);
                        const c1 = index.getX(i1 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i1 / 3);
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                if (Array.isArray(material)) {
                    for(let i2 = 0, il2 = groups.length; i2 < il2; i2++){
                        const group1 = groups[i2];
                        const groupMaterial1 = material[group1.materialIndex];
                        const start2 = Math.max(group1.start, drawRange.start);
                        const end2 = Math.min(group1.start + group1.count, drawRange.start + drawRange.count);
                        for(let j1 = start2, jl1 = end2; j1 < jl1; j1 += 3){
                            const a2 = j1;
                            const b2 = j1 + 1;
                            const c2 = j1 + 2;
                            intersection = checkBufferGeometryIntersection(this, groupMaterial1, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j1 / 3);
                                intersection.face.materialIndex = group1.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else {
                    const start3 = Math.max(0, drawRange.start);
                    const end3 = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i3 = start3, il3 = end3; i3 < il3; i3 += 3){
                        const a3 = i3;
                        const b3 = i3 + 1;
                        const c3 = i3 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i3 / 3);
                            intersects.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) {
            const isMultiMaterial = Array.isArray(material);
            const vertices = geometry.vertices;
            const faces = geometry.faces;
            let uvs;
            const faceVertexUvs = geometry.faceVertexUvs[0];
            if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
            for(let f = 0, fl = faces.length; f < fl; f++){
                const face = faces[f];
                const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                if (faceMaterial === undefined) continue;
                const fvA = vertices[face.a];
                const fvB = vertices[face.b];
                const fvC = vertices[face.c];
                intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
                if (intersection) {
                    if (uvs && uvs[f]) {
                        const uvs_f = uvs[f];
                        _uvA.copy(uvs_f[0]);
                        _uvB.copy(uvs_f[1]);
                        _uvC.copy(uvs_f[2]);
                        intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
                    }
                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push(intersection);
                }
            }
        }
    }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === 1) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA.fromBufferAttribute(position, a);
    _vB.fromBufferAttribute(position, b);
    _vC.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i = 0, il = morphPosition.length; i < il; i++){
            const influence = morphInfluences[i];
            const morphAttribute = morphPosition[i];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a);
            _tempB.fromBufferAttribute(morphAttribute, b);
            _tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA), influence);
                _morphB.addScaledVector(_tempB.sub(_vB), influence);
                _morphC.addScaledVector(_tempC.sub(_vC), influence);
            }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA);
        object.boneTransform(b, _vB);
        object.boneTransform(c, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA.fromBufferAttribute(uv, a);
            _uvB.fromBufferAttribute(uv, b);
            _uvC.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        if (uv2) {
            _uvA.fromBufferAttribute(uv2, a);
            _uvB.fromBufferAttribute(uv2, b);
            _uvC.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        const face = new Face3(a, b, c);
        Triangle.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
    }
    return intersection;
}
class BoxBufferGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = "BoxBufferGeometry";
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            const segmentWidth = width / gridX;
            const segmentHeight = height / gridY;
            const widthHalf = width / 2;
            const heightHalf = height / 2;
            const depthHalf = depth / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for(let iy = 0; iy < gridY1; iy++){
                const y = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    vertices.push(vector.x, vector.y, vector.z);
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    normals.push(vector.x, vector.y, vector.z);
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    vertexCounter += 1;
                }
            }
            for(let iy1 = 0; iy1 < gridY; iy1++){
                for(let ix1 = 0; ix1 < gridX; ix1++){
                    const a = numberOfVertices + ix1 + gridX1 * iy1;
                    const b = numberOfVertices + ix1 + gridX1 * (iy1 + 1);
                    const c = numberOfVertices + (ix1 + 1) + gridX1 * (iy1 + 1);
                    const d = numberOfVertices + (ix1 + 1) + gridX1 * iy1;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
        }
    }
}
function cloneUniforms(src) {
    const dst = {};
    for(const u in src){
        dst[u] = {};
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
                dst[u][p] = property.clone();
            } else if (Array.isArray(property)) {
                dst[u][p] = property.slice();
            } else {
                dst[u][p] = property;
            }
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {};
    for(let u = 0; u < uniforms.length; u++){
        const tmp = cloneUniforms(uniforms[u]);
        for(const p in tmp){
            merged[p] = tmp[p];
        }
    }
    return merged;
}
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
const __default = `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`;
const __default1 = `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;
function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = __default;
    this.fragmentShader = __default1;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
        "color": [
            1,
            1,
            1
        ],
        "uv": [
            0,
            0
        ],
        "uv2": [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) {
            console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
    }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
    const data = Material.prototype.toJSON.call(this, meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for(const name in this.uniforms){
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
            data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
            };
        } else if (value && value.isColor) {
            data.uniforms[name] = {
                type: "c",
                value: value.getHex()
            };
        } else if (value && value.isVector2) {
            data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
            };
        } else if (value && value.isVector3) {
            data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
            };
        } else if (value && value.isVector4) {
            data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
            };
        } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
            };
        } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
            };
        } else {
            data.uniforms[name] = {
                value: value
            };
        }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for(const key in this.extensions){
        if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
function Camera() {
    Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn("THREE.Camera: .getWorldDirection() target is now required");
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
function PerspectiveCamera(fov, aspect, near, far) {
    Camera.call(this);
    this.type = "PerspectiveCamera";
    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    setFocalLength: function(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
            this.view = {
                enabled: true,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) {
            this.view.enabled = false;
        }
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const near = this.near;
        let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
function CubeCamera(near, far, renderTarget) {
    Object3D.call(this);
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(90, 1, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(90, 1, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(90, 1, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(90, 1, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(90, 1, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(90, 1, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i = 0; i < 6; i++){
            renderer.setRenderTarget(renderTarget, i);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
    this._needsFlipEnvMap = true;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, "images", {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
function WebGLCubeRenderTarget(size, options, dummy) {
    if (Number.isInteger(options)) {
        console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
        options = dummy;
    }
    WebGLRenderTarget.call(this, size, size, options);
    options = options || {};
    this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture._needsFlipEnvMap = false;
}
WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,
        fragmentShader: `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
    };
    const geometry = new BoxBufferGeometry(5, 5, 5);
    const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) {
        texture.minFilter = LinearFilter;
    }
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
};
function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
const _sphere1 = new Sphere();
const _vector5 = new Vector3();
class Frustum {
    constructor(p0, p1, p2, p3, p4, p5){
        this.planes = [
            p0 !== undefined ? p0 : new Plane(),
            p1 !== undefined ? p1 : new Plane(),
            p2 !== undefined ? p2 : new Plane(),
            p3 !== undefined ? p3 : new Plane(),
            p4 !== undefined ? p4 : new Plane(),
            p5 !== undefined ? p5 : new Plane(), 
        ];
    }
    set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(frustum) {
        const planes = this.planes;
        for(let i = 0; i < 6; i++){
            planes[i].copy(frustum.planes[i]);
        }
        return this;
    }
    setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    }
    intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere1);
    }
    intersectsSprite(sprite) {
        _sphere1.center.set(0, 0, 0);
        _sphere1.radius = 0.7071067811865476;
        _sphere1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere1);
    }
    intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for(let i = 0; i < 6; i++){
            const distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
                return false;
            }
        }
        return true;
    }
    intersectsBox(box) {
        const planes = this.planes;
        for(let i = 0; i < 6; i++){
            const plane = planes[i];
            _vector5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector5) < 0) {
                return false;
            }
        }
        return true;
    }
    containsPoint(point) {
        const planes = this.planes;
        for(let i = 0; i < 6; i++){
            if (planes[i].distanceToPoint(point) < 0) {
                return false;
            }
        }
        return true;
    }
}
function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = gl.FLOAT;
        if (array instanceof Float32Array) {
            type = gl.FLOAT;
        } else if (array instanceof Float64Array) {
            console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
        } else if (array instanceof Uint16Array) {
            type = gl.UNSIGNED_SHORT;
        } else if (array instanceof Int16Array) {
            type = gl.SHORT;
        } else if (array instanceof Uint32Array) {
            type = gl.UNSIGNED_INT;
        } else if (array instanceof Int32Array) {
            type = gl.INT;
        } else if (array instanceof Int8Array) {
            type = gl.BYTE;
        } else if (array instanceof Uint8Array) {
            type = gl.UNSIGNED_BYTE;
        }
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) {
            gl.bufferSubData(bufferType, 0, array);
        } else {
            if (isWebGL2) {
                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            } else {
                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }
            updateRange.count = -1;
        }
    }
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
            var cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) {
                buffers.set(attribute, {
                    buffer: attribute.buffer,
                    type: attribute.type,
                    bytesPerElement: attribute.elementSize,
                    version: attribute.version
                });
            }
            return;
        }
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) {
            buffers.set(attribute, createBuffer(attribute, bufferType));
        } else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
class PlaneBufferGeometry extends BufferGeometry {
    constructor(width, height, widthSegments, heightSegments){
        super();
        this.type = "PlaneBufferGeometry";
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        width = width || 1;
        height = height || 1;
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments) || 1;
        const gridY = Math.floor(heightSegments) || 1;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for(let iy = 0; iy < gridY1; iy++){
            const y = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
            }
        }
        for(let iy1 = 0; iy1 < gridY; iy1++){
            for(let ix1 = 0; ix1 < gridX; ix1++){
                const a = ix1 + gridX1 * iy1;
                const b = ix1 + gridX1 * (iy1 + 1);
                const c = ix1 + 1 + gridX1 * (iy1 + 1);
                const d = ix1 + 1 + gridX1 * iy1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
}
const __default2 = `
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`;
const __default3 = `
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;
const __default4 = `
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`;
const __default5 = `
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`;
const __default6 = `
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`;
const __default7 = `
vec3 transformed = vec3( position );
`;
const __default8 = `
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`;
const __default9 = `

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`;
const __default10 = `
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 );

		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`;
const __default11 = `
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`;
const __default12 = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`;
const __default13 = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`;
const __default14 = `
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`;
const __default15 = `
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif
`;
const __default16 = `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`;
const __default17 = `
#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`;
const __default18 = `
#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor.xyz *= color.xyz;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`;
const __default19 = `
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`;
const __default20 = `
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`;
const __default21 = `
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`;
const __default22 = `
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`;
const __default23 = `
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`;
const __default24 = `
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`;
const __default25 = `
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`;
const __default26 = `
gl_FragColor = linearToOutputTexel( gl_FragColor );
`;
const __default27 = `
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`;
const __default28 = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`;
const __default29 = `
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`;
const __default30 = `
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`;
const __default31 = `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`;
const __default32 = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`;
const __default33 = `
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`;
const __default34 = `
#ifdef USE_FOG

	varying float fogDepth;

#endif
`;
const __default35 = `
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`;
const __default36 = `
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`;
const __default37 = `

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`;
const __default38 = `
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`;
const __default39 = `
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`;
const __default40 = `
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`;
const __default41 = `
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`;
const __default42 = `
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`;
const __default43 = `
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`;
const __default44 = `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`;
const __default45 = `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`;
const __default46 = `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`;
const __default47 = `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`;
const __default48 = `
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`;
const __default49 = `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`;
const __default50 = `
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`;
const __default51 = `
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`;
const __default52 = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`;
const __default53 = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`;
const __default54 = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`;
const __default55 = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`;
const __default56 = `
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`;
const __default57 = `
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`;
const __default58 = `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;
const __default59 = `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;
const __default60 = `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`;
const __default61 = `
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`;
const __default62 = `
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`;
const __default63 = `
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`;
const __default64 = `
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`;
const __default65 = `
#ifdef FLAT_SHADED

	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`;
const __default66 = `

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );

#endif
`;
const __default67 = `
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Per-Pixel Tangent Space Normal Mapping
	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );

		mat3 tsn = mat3( S, T, N );

		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		return normalize( tsn * mapN );

	}

#endif
`;
const __default68 = `
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`;
const __default69 = `
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );

	#endif

#endif
`;
const __default70 = `

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`;
const __default71 = `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`;
const __default72 = `
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`;
const __default73 = `
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`;
const __default74 = `
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`;
const __default75 = `
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`;
const __default76 = `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`;
const __default77 = `
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`;
const __default78 = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`;
const __default79 = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`;
const __default80 = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`;
const __default81 = `
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`;
const __default82 = `
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`;
const __default83 = `
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`;
const __default84 = `
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`;
const __default85 = `
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`;
const __default86 = `
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`;
const __default87 = `
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`;
const __default88 = `
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`;
const __default89 = `
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`;
const __default90 = `
#ifdef USE_TRANSMISSIONMAP

	totalTransmission *= texture2D( transmissionMap, vUv ).r;

#endif
`;
const __default91 = `
#ifdef USE_TRANSMISSIONMAP

	uniform sampler2D transmissionMap;

#endif
`;
const __default92 = `
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`;
const __default93 = `
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`;
const __default94 = `
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`;
const __default95 = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`;
const __default96 = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`;
const __default97 = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`;
const __default98 = `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`;
const __default99 = `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
const __default100 = `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`;
const __default101 = `
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
const __default102 = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;
const __default103 = `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`;
const __default104 = `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`;
const __default105 = `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`;
const __default106 = `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`;
const __default107 = `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
const __default108 = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`;
const __default109 = `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;
const __default110 = `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;
const __default111 = `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
const __default112 = `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`;
const __default113 = `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
const __default114 = `
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`;
const __default115 = `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
const __default116 = `
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`;
const __default117 = `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
const __default118 = `
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
const __default119 = `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
const __default120 = `
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
const __default121 = `
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSMISSION
	uniform float transmission;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transmission model
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
const __default122 = `
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
const __default123 = `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`;
const __default124 = `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`;
const __default125 = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;
const __default126 = `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;
const __default127 = `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;
const __default128 = `
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
const __default129 = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;
const __default130 = `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;
const ShaderChunk = {
    alphamap_fragment: __default2,
    alphamap_pars_fragment: __default3,
    alphatest_fragment: __default4,
    aomap_fragment: __default5,
    aomap_pars_fragment: __default6,
    begin_vertex: __default7,
    beginnormal_vertex: __default8,
    bsdfs: __default9,
    bumpmap_pars_fragment: __default10,
    clipping_planes_fragment: __default11,
    clipping_planes_pars_fragment: __default12,
    clipping_planes_pars_vertex: __default13,
    clipping_planes_vertex: __default14,
    color_fragment: __default15,
    color_pars_fragment: __default16,
    color_pars_vertex: __default17,
    color_vertex: __default18,
    common: __default19,
    cube_uv_reflection_fragment: __default20,
    defaultnormal_vertex: __default21,
    displacementmap_pars_vertex: __default22,
    displacementmap_vertex: __default23,
    emissivemap_fragment: __default24,
    emissivemap_pars_fragment: __default25,
    encodings_fragment: __default26,
    encodings_pars_fragment: __default27,
    envmap_fragment: __default28,
    envmap_common_pars_fragment: __default29,
    envmap_pars_fragment: __default30,
    envmap_pars_vertex: __default31,
    envmap_physical_pars_fragment: __default42,
    envmap_vertex: __default32,
    fog_vertex: __default33,
    fog_pars_vertex: __default34,
    fog_fragment: __default35,
    fog_pars_fragment: __default36,
    gradientmap_pars_fragment: __default37,
    lightmap_fragment: __default38,
    lightmap_pars_fragment: __default39,
    lights_lambert_vertex: __default40,
    lights_pars_begin: __default41,
    lights_toon_fragment: __default43,
    lights_toon_pars_fragment: __default44,
    lights_phong_fragment: __default45,
    lights_phong_pars_fragment: __default46,
    lights_physical_fragment: __default47,
    lights_physical_pars_fragment: __default48,
    lights_fragment_begin: __default49,
    lights_fragment_maps: __default50,
    lights_fragment_end: __default51,
    logdepthbuf_fragment: __default52,
    logdepthbuf_pars_fragment: __default53,
    logdepthbuf_pars_vertex: __default54,
    logdepthbuf_vertex: __default55,
    map_fragment: __default56,
    map_pars_fragment: __default57,
    map_particle_fragment: __default58,
    map_particle_pars_fragment: __default59,
    metalnessmap_fragment: __default60,
    metalnessmap_pars_fragment: __default61,
    morphnormal_vertex: __default62,
    morphtarget_pars_vertex: __default63,
    morphtarget_vertex: __default64,
    normal_fragment_begin: __default65,
    normal_fragment_maps: __default66,
    normalmap_pars_fragment: __default67,
    clearcoat_normal_fragment_begin: __default68,
    clearcoat_normal_fragment_maps: __default69,
    clearcoat_pars_fragment: __default70,
    packing: __default71,
    premultiplied_alpha_fragment: __default72,
    project_vertex: __default73,
    dithering_fragment: __default74,
    dithering_pars_fragment: __default75,
    roughnessmap_fragment: __default76,
    roughnessmap_pars_fragment: __default77,
    shadowmap_pars_fragment: __default78,
    shadowmap_pars_vertex: __default79,
    shadowmap_vertex: __default80,
    shadowmask_pars_fragment: __default81,
    skinbase_vertex: __default82,
    skinning_pars_vertex: __default83,
    skinning_vertex: __default84,
    skinnormal_vertex: __default85,
    specularmap_fragment: __default86,
    specularmap_pars_fragment: __default87,
    tonemapping_fragment: __default88,
    tonemapping_pars_fragment: __default89,
    transmissionmap_fragment: __default90,
    transmissionmap_pars_fragment: __default91,
    uv_pars_fragment: __default92,
    uv_pars_vertex: __default93,
    uv_vertex: __default94,
    uv2_pars_fragment: __default95,
    uv2_pars_vertex: __default96,
    uv2_vertex: __default97,
    worldpos_vertex: __default98,
    background_frag: __default99,
    background_vert: __default100,
    cube_frag: __default101,
    cube_vert: __default102,
    depth_frag: __default103,
    depth_vert: __default104,
    distanceRGBA_frag: __default105,
    distanceRGBA_vert: __default106,
    equirect_frag: __default107,
    equirect_vert: __default108,
    linedashed_frag: __default109,
    linedashed_vert: __default110,
    meshbasic_frag: __default111,
    meshbasic_vert: __default112,
    meshlambert_frag: __default113,
    meshlambert_vert: __default114,
    meshmatcap_frag: __default115,
    meshmatcap_vert: __default116,
    meshtoon_frag: __default117,
    meshtoon_vert: __default118,
    meshphong_frag: __default119,
    meshphong_vert: __default120,
    meshphysical_frag: __default121,
    meshphysical_vert: __default122,
    normal_frag: __default123,
    normal_vert: __default124,
    points_frag: __default125,
    points_vert: __default126,
    shadow_frag: __default127,
    shadow_vert: __default128,
    sprite_frag: __default129,
    sprite_vert: __default130
};
const UniformsLib = {
    common: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        },
        uv2Transform: {
            value: new Matrix3()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1.0
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(0xffffff)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        size: {
            value: 1.0
        },
        scale: {
            value: 1.0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    },
    sprite: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        center: {
            value: new Vector2(0.5, 0.5)
        },
        rotation: {
            value: 0.0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    }
};
const ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog, 
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                }
            }, 
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                },
                specular: {
                    value: new Color(0x111111)
                },
                shininess: {
                    value: 30
                }
            }, 
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                },
                roughness: {
                    value: 1.0
                },
                metalness: {
                    value: 0.0
                },
                envMapIntensity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                }
            }, 
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
                matcap: {
                    value: null
                }
            }, 
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog, 
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }, 
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap, 
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
                opacity: {
                    value: 1.0
                }
            }, 
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog, 
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    cube: {
        uniforms: mergeUniforms([
            UniformsLib.envmap,
            {
                opacity: {
                    value: 1.0
                }
            }, 
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }, 
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
                color: {
                    value: new Color(0x00000)
                },
                opacity: {
                    value: 1.0
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector2(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Color(0x000000)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }, 
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0x000000);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera, forceClear) {
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) {
            background = cubemaps.get(background);
        }
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === "additive") {
            background = null;
        }
        if (background === null) {
            setClear(clearColor, clearAlpha);
        } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        }
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === 306)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                    name: "BackgroundCubeMaterial",
                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                    vertexShader: ShaderLib.cube.vertexShader,
                    fragmentShader: ShaderLib.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute("normal");
                boxMesh.geometry.deleteAttribute("uv");
                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                Object.defineProperty(boxMesh.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            if (background.isWebGLCubeRenderTarget) {
                background = background.texture;
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                    name: "BackgroundMaterial",
                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                    vertexShader: ShaderLib.background.vertexShader,
                    fragmentShader: ShaderLib.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute("normal");
                Object.defineProperty(planeMesh.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) {
                background.updateMatrix();
            }
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha) {
            clearColor.set(color);
            clearAlpha = alpha !== undefined ? alpha : 1;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers) saveCache(geometry, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) {
            updateBuffers = true;
        }
        if (index !== null) {
            attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
        }
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
            }
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {};
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i = 0; i < maxVertexAttributes; i++){
            newAttributes[i] = 0;
            enabledAttributes[i] = 0;
            attributeDivisors[i] = 0;
        }
        return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {},
            index: null
        };
    }
    function needsUpdate(geometry, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) {
            return true;
        }
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
        }
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry, index) {
        const cache = {};
        const attributes = geometry.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) {
                data.data = attribute.data;
            }
            cache[key] = data;
        }
        currentState.attributes = cache;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i = 0, il = newAttributes.length; i < il; i++){
            newAttributes[i] = 0;
        }
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i = 0, il = enabledAttributes.length; i < il; i++){
            if (enabledAttributes[i] !== newAttributes[i]) {
                gl.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
            gl.vertexAttribIPointer(index, size, type, stride, offset);
        } else {
            gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
        }
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes.get(geometryAttribute);
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) {
                                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                            }
                        } else {
                            enableAttribute(programAttribute);
                        }
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) {
                                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                            }
                        } else {
                            enableAttribute(programAttribute);
                        }
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                    }
                } else if (name === "instanceMatrix") {
                    const attribute1 = attributes.get(object.instanceMatrix);
                    if (attribute1 === undefined) continue;
                    const buffer1 = attribute1.buffer;
                    const type1 = attribute1.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer1);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type1, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type1, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type1, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type1, false, 64, 48);
                } else if (name === "instanceColor") {
                    const attribute2 = attributes.get(object.instanceColor);
                    if (attribute2 === undefined) continue;
                    const buffer2 = attribute2.buffer;
                    const type2 = attribute2.type;
                    enableAttributeAndDivisor(programAttribute, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
                    gl.vertexAttribPointer(programAttribute, 3, type2, false, 12, 0);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) {
                        switch(value.length){
                            case 2:
                                gl.vertexAttrib2fv(programAttribute, value);
                                break;
                            case 3:
                                gl.vertexAttrib3fv(programAttribute, value);
                                break;
                            case 4:
                                gl.vertexAttrib4fv(programAttribute, value);
                                break;
                            default:
                                gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = "drawArraysInstanced";
        } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension !== null) {
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
            maxAnisotropy = 0;
        }
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return "highp";
            }
            precision = "mediump";
        }
        if (precision === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return "mediump";
            }
        }
        return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== undefined ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
        precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
        const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        const materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
                projectPlanes(null);
            } else {
                resetGlobalState();
            }
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for(let i = 0; i !== lGlobal; ++i){
                dstArray[i] = globalState[i];
            }
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) {
                    dstArray = new Float32Array(flatSize);
                }
                for(let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4){
                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
    }
}
function WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === 303) {
            texture.mapping = CubeReflectionMapping;
        } else if (mapping === 304) {
            texture.mapping = CubeRefractionMapping;
        }
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            if (mapping === 303 || mapping === 304) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const currentRenderList = renderer.getRenderList();
                        const currentRenderTarget = renderer.getRenderTarget();
                        const currentRenderState = renderer.getRenderState();
                        const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        renderer.setRenderTarget(currentRenderTarget);
                        renderer.setRenderList(currentRenderList);
                        renderer.setRenderState(currentRenderState);
                        texture.addEventListener("dispose", onTextureDispose);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else {
                        return null;
                    }
                }
            }
        }
        return texture;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        const cubemap = cubemaps.get(texture);
        if (cubemap !== undefined) {
            cubemaps.delete(texture);
            cubemap.dispose();
        }
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function WebGLExtensions(gl) {
    const extensions = {};
    return {
        has: function(name) {
            if (extensions[name] !== undefined) {
                return extensions[name] !== null;
            }
            let extension;
            switch(name){
                case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            extensions[name] = extension;
            return extension !== null;
        },
        get: function(name) {
            if (!this.has(name)) {
                console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            }
            return extensions[name];
        }
    };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = new WeakMap();
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        const buffergeometry = geometries.get(geometry);
        if (buffergeometry.index !== null) {
            attributes.remove(buffergeometry.index);
        }
        for(const name in buffergeometry.attributes){
            attributes.remove(buffergeometry.attributes[name]);
        }
        geometry.removeEventListener("dispose", onGeometryDispose);
        geometries.delete(geometry);
        const attribute = wireframeAttributes.get(buffergeometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(buffergeometry);
        }
        bindingStates.releaseStatesOfGeometry(buffergeometry);
        if (geometry.isInstancedBufferGeometry === true) {
            delete geometry._maxInstanceCount;
        }
        info.memory.geometries--;
    }
    function get(object, geometry) {
        let buffergeometry = geometries.get(geometry);
        if (buffergeometry) return buffergeometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        if (geometry.isBufferGeometry) {
            buffergeometry = geometry;
        } else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) {
                geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
            }
            buffergeometry = geometry._bufferGeometry;
        }
        geometries.set(geometry, buffergeometry);
        info.memory.geometries++;
        return buffergeometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        for(const name in geometryAttributes){
            attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
        }
        const morphAttributes = geometry.morphAttributes;
        for(const name1 in morphAttributes){
            const array = morphAttributes[name1];
            for(let i = 0, l = array.length; i < l; i++){
                attributes.update(array[i], gl.ARRAY_BUFFER);
            }
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i = 0, l = array.length; i < l; i += 3){
                const a = array[i + 0];
                const b = array[i + 1];
                const c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            const array1 = geometryPosition.array;
            version = geometryPosition.version;
            for(let i1 = 0, l1 = array1.length / 3 - 1; i1 < l1; i1 += 3){
                const a1 = i1 + 0;
                const b1 = i1 + 1;
                const c1 = i1 + 2;
                indices.push(a1, b1, b1, c1, c1, a1);
            }
        }
        const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) {
                if (currentAttribute.version < geometryIndex.version) {
                    updateWireframeAttribute(geometry);
                }
            }
        } else {
            updateWireframeAttribute(geometry);
        }
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = "drawElementsInstanced";
        } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
                console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case gl.TRIANGLES:
                render.triangles += instanceCount * (count / 3);
                break;
            case gl.LINES:
                render.lines += instanceCount * (count / 2);
                break;
            case gl.LINE_STRIP:
                render.lines += instanceCount * (count - 1);
                break;
            case gl.LINE_LOOP:
                render.lines += instanceCount * count;
                break;
            case gl.POINTS:
                render.points += instanceCount * count;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
function numericalSort(a, b) {
    return a[0] - b[0];
}
function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i = 0; i < 8; i++){
        workInfluences[i] = [
            i,
            0
        ];
    }
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined) {
            influences = [];
            for(let i = 0; i < length; i++){
                influences[i] = [
                    i,
                    0
                ];
            }
            influencesList[geometry.id] = influences;
        }
        for(let i1 = 0; i1 < length; i1++){
            const influence = influences[i1];
            influence[0] = i1;
            influence[1] = objectInfluences[i1];
        }
        influences.sort(absNumericalSort);
        for(let i2 = 0; i2 < 8; i2++){
            if (i2 < length && influences[i2][1]) {
                workInfluences[i2][0] = influences[i2][0];
                workInfluences[i2][1] = influences[i2][1];
            } else {
                workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[i2][1] = 0;
            }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = material.morphTargets && geometry.morphAttributes.position;
        const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i3 = 0; i3 < 8; i3++){
            const influence1 = workInfluences[i3];
            const index = influence1[0];
            const value = influence1[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute("morphTarget" + i3) !== morphTargets[index]) {
                    geometry.setAttribute("morphTarget" + i3, morphTargets[index]);
                }
                if (morphNormals && geometry.getAttribute("morphNormal" + i3) !== morphNormals[index]) {
                    geometry.setAttribute("morphNormal" + i3, morphNormals[index]);
                }
                morphInfluences[i3] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry.getAttribute("morphTarget" + i3) !== undefined) {
                    geometry.deleteAttribute("morphTarget" + i3);
                }
                if (morphNormals && geometry.getAttribute("morphNormal" + i3) !== undefined) {
                    geometry.deleteAttribute("morphNormal" + i3);
                }
                morphInfluences[i3] = 0;
            }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
    return {
        update: update
    };
}
function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        if (updateMap.get(buffergeometry) !== frame) {
            if (geometry.isGeometry) {
                buffergeometry.updateFromObject(object);
            }
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) {
                attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
            }
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    return {
        update: update,
        dispose: dispose
    };
}
function DataTexture2DArray(data, width, height, depth) {
    Texture.call(this, null);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function DataTexture3D(data, width, height, depth) {
    Texture.call(this, null);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i = 1, offset = 0; i !== nBlocks; ++i){
            offset += blockSize;
            array[i].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0, l = a.length; i < l; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function copyArray(a, b) {
    for(let i = 0, l = b.length; i < l; i++){
        a[i] = b[i];
    }
}
function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(let i = 0; i !== n; ++i){
        r[i] = textures.allocateTextureUnit();
    }
    return r;
}
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
function getSingularSetter(type) {
    switch(type){
        case 0x1406:
            return setValueV1f;
        case 0x8b50:
            return setValueV2f;
        case 0x8b51:
            return setValueV3f;
        case 0x8b52:
            return setValueV4f;
        case 0x8b5a:
            return setValueM2;
        case 0x8b5b:
            return setValueM3;
        case 0x8b5c:
            return setValueM4;
        case 0x1404:
        case 0x8b56:
            return setValueV1i;
        case 0x8b53:
        case 0x8b57:
            return setValueV2i;
        case 0x8b54:
        case 0x8b58:
            return setValueV3i;
        case 0x8b55:
        case 0x8b59:
            return setValueV4i;
        case 0x1405:
            return setValueV1ui;
        case 0x8b5e:
        case 0x8d66:
        case 0x8dca:
        case 0x8dd2:
        case 0x8b62:
            return setValueT1;
        case 0x8b5f:
        case 0x8dcb:
        case 0x8dd3:
            return setValueT3D1;
        case 0x8b60:
        case 0x8dcc:
        case 0x8dd4:
        case 0x8dc5:
            return setValueT6;
        case 0x8dc1:
        case 0x8dcf:
        case 0x8dd7:
        case 0x8dc4:
            return setValueT2DArray1;
    }
}
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i = 0; i !== n; ++i){
        textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
    }
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i = 0; i !== n; ++i){
        textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
}
function getPureArraySetter(type) {
    switch(type){
        case 0x1406:
            return setValueV1fArray;
        case 0x8b50:
            return setValueV2fArray;
        case 0x8b51:
            return setValueV3fArray;
        case 0x8b52:
            return setValueV4fArray;
        case 0x8b5a:
            return setValueM2Array;
        case 0x8b5b:
            return setValueM3Array;
        case 0x8b5c:
            return setValueM4Array;
        case 0x1404:
        case 0x8b56:
            return setValueV1iArray;
        case 0x8b53:
        case 0x8b57:
            return setValueV2iArray;
        case 0x8b54:
        case 0x8b58:
            return setValueV3iArray;
        case 0x8b55:
        case 0x8b59:
            return setValueV4iArray;
        case 0x8b5e:
        case 0x8d66:
        case 0x8dca:
        case 0x8dd2:
        case 0x8b62:
            return setValueT1Array;
        case 0x8b60:
        case 0x8dcc:
        case 0x8dd4:
        case 0x8dc5:
            return setValueT6Array;
    }
}
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i = 0, n = seq.length; i !== n; ++i){
        const u = seq[i];
        u.setValue(gl, value[u.id], textures);
    }
};
const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex) id = id | 0;
        if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for(let i = 0; i < n; ++i){
        const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i = 0, n = seq.length; i !== n; ++i){
        const u = seq[i], v = values[u.id];
        if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, textures);
        }
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for(let i = 0, n = seq.length; i !== n; ++i){
        const u = seq[i];
        if (u.id in values) r.push(u);
    }
    return r;
};
function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split("\n");
    for(let i = 0; i < lines.length; i++){
        lines[i] = i + 1 + ": " + lines[i];
    }
    return lines.join("\n");
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case 3000:
            return [
                "Linear",
                "( value )"
            ];
        case 3001:
            return [
                "sRGB",
                "( value )"
            ];
        case 3002:
            return [
                "RGBE",
                "( value )"
            ];
        case 3004:
            return [
                "RGBM",
                "( value, 7.0 )"
            ];
        case 3005:
            return [
                "RGBM",
                "( value, 16.0 )"
            ];
        case 3006:
            return [
                "RGBD",
                "( value, 256.0 )"
            ];
        case 3007:
            return [
                "Gamma",
                "( value, float( GAMMA_FACTOR ) )"
            ];
        case 3003:
            return [
                "LogLuv",
                "( value )"
            ];
        default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return [
                "Linear",
                "( value )"
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === "") return "";
    const source = gl.getShaderSource(shader);
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case 1:
            toneMappingName = "Linear";
            break;
        case 2:
            toneMappingName = "Reinhard";
            break;
        case 3:
            toneMappingName = "OptimizedCineon";
            break;
        case 4:
            toneMappingName = "ACESFilmic";
            break;
        case 5:
            toneMappingName = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : "", 
    ];
    return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for(let i = 0; i < n; i++){
        const info = gl.getActiveAttrib(program, i);
        const name = info.name;
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== "";
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) {
        throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = "";
    for(let i = parseInt(start); i < parseInt(end); i++){
        string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
}
function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
        precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
        precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
        precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === 1) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === 2) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === 3) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
        switch(parameters.envMapMode){
            case 301:
            case 302:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
        switch(parameters.envMapMode){
            case 302:
            case 307:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                break;
        }
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
        switch(parameters.combine){
            case 0:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                break;
        }
    }
    return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines, 
        ].filter(filterEmptyLine).join("\n");
        if (prefixVertex.length > 0) {
            prefixVertex += "\n";
        }
        prefixFragment = [
            customExtensions,
            customDefines, 
        ].filter(filterEmptyLine).join("\n");
        if (prefixFragment.length > 0) {
            prefixFragment += "\n";
        }
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.instancing ? "#define USE_INSTANCING" : "",
            parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            "#define MAX_BONES " + parameters.maxBones,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors ? "#define USE_COLOR" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.skinning ? "#define USE_SKINNING" : "",
            parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
            parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
            parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#ifdef USE_COLOR",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_MORPHTARGETS",
            "	attribute vec3 morphTarget0;",
            "	attribute vec3 morphTarget1;",
            "	attribute vec3 morphTarget2;",
            "	attribute vec3 morphTarget3;",
            "	#ifdef USE_MORPHNORMALS",
            "		attribute vec3 morphNormal0;",
            "		attribute vec3 morphNormal1;",
            "		attribute vec3 morphNormal2;",
            "		attribute vec3 morphNormal3;",
            "	#else",
            "		attribute vec3 morphTarget4;",
            "		attribute vec3 morphTarget5;",
            "		attribute vec3 morphTarget6;",
            "		attribute vec3 morphTarget7;",
            "	#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            "\n", 
        ].filter(filterEmptyLine).join("\n");
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            ShaderChunk["encodings_pars_fragment"],
            parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
            parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
            parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
            parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
            parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
            getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
            parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n", 
        ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        versionString = "#version 300 es\n";
        prefixVertex = [
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture", 
        ].join("\n") + "\n" + prefixVertex;
        prefixFragment = [
            "#define varying in",
            parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
            parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad", 
        ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== undefined) {
        gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== "") {
            console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
        }
        if (haveDiagnostics) {
            this.diagnostics = {
                runnable: runnable,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) {
            cachedUniforms = new WebGLUniforms(gl, program);
        }
        return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) {
            cachedAttributes = fetchAttributeLocations(gl, program);
        }
        return cachedAttributes;
    };
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    const parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        "physicallyCorrectLights",
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "sheen",
        "transmissionMap", 
    ];
    function getMaxBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) {
            return 1024;
        } else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (!map) {
            encoding = LinearEncoding;
        } else if (map.isTexture) {
            encoding = map.encoding;
        } else if (map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
        }
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = cubemaps.get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
                console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            }
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === 306 || envMap.mapping === 307),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === 1,
            tangentSpaceNormalMap: material.normalMapType === 0,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            transmissionMap: !!material.transmissionMap,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : 0,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === 2,
            flipSided: material.side === 1,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) {
            array.push(parameters.shaderID);
        } else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) {
            for(const name in parameters.defines){
                array.push(name);
                array.push(parameters.defines[name]);
            }
        }
        if (parameters.isRawShaderMaterial === false) {
            for(let i = 0; i < parameterNames.length; i++){
                array.push(parameters[parameterNames[i]]);
            }
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
        } else {
            uniforms = material.uniforms;
        }
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if (--program.usedTimes === 0) {
            const i = programs.indexOf(program);
            programs[i] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        programs: programs
    };
}
function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {};
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
    } else if (a.program !== b.program) {
        return a.program.id - b.program.id;
    } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
        return a.z - b.z;
    } else {
        return a.id - b.id;
    }
}
function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
        return b.z - a.z;
    } else {
        return a.id - b.id;
    }
}
function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) {
            transparent.sort(customTransparentSort || reversePainterSortStable);
        }
    }
    function finish() {
        for(let i = renderItemsIndex, il = renderItems.length; i < il; i++){
            const renderItem = renderItems[i];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, camera) {
        const cameras = lists.get(scene);
        let list;
        if (cameras === undefined) {
            list = new WebGLRenderList(properties);
            lists.set(scene, new WeakMap());
            lists.get(scene).set(camera, list);
        } else {
            list = cameras.get(camera);
            if (list === undefined) {
                list = new WebGLRenderList(properties);
                cameras.set(camera, list);
            }
        }
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function UniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) {
                return lights[light.id];
            }
            let uniforms;
            switch(light.type){
                case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color()
                    };
                    break;
                case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;
                case "RectAreaLight":
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) {
                return lights[light.id];
            }
            let uniforms;
            switch(light.type){
                case "DirectionalLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case "SpotLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case "PointLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights() {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i = 0; i < 9; i++)state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, shadows, camera) {
        let r = 0, g = 0, b = 0;
        for(let i = 0; i < 9; i++)state.probe[i].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        const viewMatrix = camera.matrixWorldInverse;
        lights.sort(shadowCastingLightsFirst);
        for(let i1 = 0, l = lights.length; i1 < l; i1++){
            const light = lights[i1];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
            } else if (light.isLightProbe) {
                for(let j = 0; j < 9; j++){
                    state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                }
            } else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms1 = cache.get(light);
                uniforms1.position.setFromMatrixPosition(light.matrixWorld);
                uniforms1.position.applyMatrix4(viewMatrix);
                uniforms1.color.copy(color).multiplyScalar(intensity);
                uniforms1.distance = distance;
                uniforms1.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms1.direction.sub(vector3);
                uniforms1.direction.transformDirection(viewMatrix);
                uniforms1.coneCos = Math.cos(light.angle);
                uniforms1.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms1.decay = light.decay;
                if (light.castShadow) {
                    const shadow1 = light.shadow;
                    const shadowUniforms1 = shadowCache.get(light);
                    shadowUniforms1.shadowBias = shadow1.bias;
                    shadowUniforms1.shadowNormalBias = shadow1.normalBias;
                    shadowUniforms1.shadowRadius = shadow1.radius;
                    shadowUniforms1.shadowMapSize = shadow1.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms1;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms1;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms2 = cache.get(light);
                uniforms2.color.copy(color).multiplyScalar(intensity);
                uniforms2.position.setFromMatrixPosition(light.matrixWorld);
                uniforms2.position.applyMatrix4(viewMatrix);
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);
                uniforms2.halfWidth.applyMatrix4(matrix42);
                uniforms2.halfHeight.applyMatrix4(matrix42);
                state.rectArea[rectAreaLength] = uniforms2;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms3 = cache.get(light);
                uniforms3.position.setFromMatrixPosition(light.matrixWorld);
                uniforms3.position.applyMatrix4(viewMatrix);
                uniforms3.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms3.distance = light.distance;
                uniforms3.decay = light.decay;
                if (light.castShadow) {
                    const shadow2 = light.shadow;
                    const shadowUniforms2 = shadowCache.get(light);
                    shadowUniforms2.shadowBias = shadow2.bias;
                    shadowUniforms2.shadowNormalBias = shadow2.normalBias;
                    shadowUniforms2.shadowRadius = shadow2.radius;
                    shadowUniforms2.shadowMapSize = shadow2.mapSize;
                    shadowUniforms2.shadowCameraNear = shadow2.camera.near;
                    shadowUniforms2.shadowCameraFar = shadow2.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms2;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms3;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms4 = cache.get(light);
                uniforms4.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms4.direction.transformDirection(viewMatrix);
                uniforms4.direction.normalize();
                uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms4;
                hemiLength++;
            }
        }
        if (rectAreaLength > 0) {
            state.rectAreaLTC1 = UniformsLib.LTC_1;
            state.rectAreaLTC2 = UniformsLib.LTC_2;
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    return {
        setup: setup,
        state: state
    };
}
function WebGLRenderState() {
    const lights = new WebGLLights();
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates() {
    let renderStates = new WeakMap();
    function get(scene, camera) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState();
            renderStates.set(scene, new WeakMap());
            renderStates.get(scene).set(camera, renderState);
        } else {
            if (renderStates.get(scene).has(camera) === false) {
                renderState = new WebGLRenderState();
                renderStates.get(scene).set(camera, renderState);
            } else {
                renderState = renderStates.get(scene).get(camera);
            }
        }
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
const __default131 = `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

		#ifdef HORIZONAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;
const __default132 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
    const shadowSide = {
        0: 1,
        1: 0,
        2: 2
    };
    const shadowMaterialVertical = new ShaderMaterial({
        defines: {
            SAMPLE_RATE: 2.0 / 8.0,
            HALF_SAMPLE_RATE: 1.0 / 8.0
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2()
            },
            radius: {
                value: 4.0
            }
        },
        vertexShader: __default132,
        fragmentShader: __default131
    });
    const shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope.enabled === false) return;
        if (scope.autoUpdate === false && scope.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        for(let i = 0, il = lights.length; i < il; i++){
            const light = lights[i];
            const shadow = light.shadow;
            if (shadow === undefined) {
                console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                if (_shadowMapSize.x > maxTextureSize) {
                    _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > maxTextureSize) {
                    _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars1 = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars1);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
                VSMPass(shadow, camera);
            }
            shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _depthMaterials[index];
        if (material === undefined) {
            material = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[index] = material;
        }
        return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _distanceMaterials[index];
        if (material === undefined) {
            material = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[index] = material;
        }
        return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material.morphTargets === true) {
                useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            }
            let useSkinning = false;
            if (object.isSkinnedMesh === true) {
                if (material.skinning === true) {
                    useSkinning = true;
                } else {
                    console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
                }
            }
            const useInstancing = object.isInstancedMesh === true;
            result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else {
            result = customMaterial;
        }
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === 3) {
            result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        } else {
            result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        }
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === 3) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial1 = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial1, object, null);
                }
            }
        }
        const children = object.children;
        for(let i = 0, l = children.length; i < l; i++){
            renderObject(children[i], camera, shadowCamera, light, type);
        }
    }
}
function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color = new Vector4();
        let currentColorMask = null;
        const currentColorClear = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a;
                    g *= a;
                    b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0);
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) {
                    enable(gl.DEPTH_TEST);
                } else {
                    disable(gl.DEPTH_TEST);
                }
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) {
                        switch(depthFunc){
                            case 0:
                                gl.depthFunc(gl.NEVER);
                                break;
                            case 1:
                                gl.depthFunc(gl.ALWAYS);
                                break;
                            case 2:
                                gl.depthFunc(gl.LESS);
                                break;
                            case 3:
                                gl.depthFunc(gl.LEQUAL);
                                break;
                            case 4:
                                gl.depthFunc(gl.EQUAL);
                                break;
                            case 5:
                                gl.depthFunc(gl.GEQUAL);
                                break;
                            case 6:
                                gl.depthFunc(gl.GREATER);
                                break;
                            case 7:
                                gl.depthFunc(gl.NOTEQUAL);
                                break;
                            default:
                                gl.depthFunc(gl.LEQUAL);
                        }
                    } else {
                        gl.depthFunc(gl.LEQUAL);
                    }
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) {
                        enable(gl.STENCIL_TEST);
                    } else {
                        disable(gl.STENCIL_TEST);
                    }
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(gl.VERSION);
    if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1.0;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2.0;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const currentScissor = new Vector4();
    const currentViewport = new Vector4();
    function createTexture(type, target, count) {
        const data = new Uint8Array(4);
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        for(let i = 0; i < count; i++){
            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
        return texture;
    }
    const emptyTextures = {};
    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl.DEPTH_TEST);
    depthBuffer.setFunc(3);
    setFlipSided(false);
    setCullFace(1);
    enable(gl.CULL_FACE);
    setBlending(0);
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [100]: gl.FUNC_ADD,
        [101]: gl.FUNC_SUBTRACT,
        [102]: gl.FUNC_REVERSE_SUBTRACT
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = gl.MIN;
        equationToGL[MaxEquation] = gl.MAX;
    } else {
        const extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [200]: gl.ZERO,
        [201]: gl.ONE,
        [202]: gl.SRC_COLOR,
        [204]: gl.SRC_ALPHA,
        [210]: gl.SRC_ALPHA_SATURATE,
        [208]: gl.DST_COLOR,
        [206]: gl.DST_ALPHA,
        [203]: gl.ONE_MINUS_SRC_COLOR,
        [205]: gl.ONE_MINUS_SRC_ALPHA,
        [209]: gl.ONE_MINUS_DST_COLOR,
        [207]: gl.ONE_MINUS_DST_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === 0) {
            if (currentBlendingEnabled) {
                disable(gl.BLEND);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
        }
        if (blending !== 5) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== 100 || currentBlendEquationAlpha !== 100) {
                    gl.blendEquation(gl.FUNC_ADD);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) {
                    switch(blending){
                        case 1:
                            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            gl.blendFunc(gl.ONE, gl.ONE);
                            break;
                        case 3:
                            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 4:
                            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", blending);
                            break;
                    }
                } else {
                    switch(blending){
                        case 1:
                            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                            break;
                        case 3:
                            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                            break;
                        case 4:
                            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", blending);
                            break;
                    }
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === 2 ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
        let flipSided = material.side === 1;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === 1 && material.transparent === false ? setBlending(0) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) {
                gl.frontFace(gl.CW);
            } else {
                gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== 0) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
                if (cullFace === 1) {
                    gl.cullFace(gl.BACK);
                } else if (cullFace === 2) {
                    gl.cullFace(gl.FRONT);
                } else {
                    gl.cullFace(gl.FRONT_AND_BACK);
                }
            }
        } else {
            disable(gl.CULL_FACE);
        }
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else {
            disable(gl.POLYGON_OFFSET_FILL);
        }
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) {
            enable(gl.SCISSOR_TEST);
        } else {
            disable(gl.SCISSOR_TEST);
        }
    }
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) {
            activeTexture();
        }
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function scissor(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    function reset() {
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas;
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {}
    function createCanvas(width, height) {
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        if (image.width > maxSize || image.height > maxSize) {
            scale = maxSize / Math.max(image.width, image.height);
        }
        if (scale < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                const width = floor(scale * image.width);
                const height = floor(scale * image.height);
                if (_canvas === undefined) _canvas = createCanvas(width, height);
                const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, width, height);
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
                return canvas;
            } else {
                if ("data" in image) {
                    console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
                }
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== 1001 || texture.wrapT !== 1001 || texture.minFilter !== 1003 && texture.minFilter !== 1006;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== 1003 && texture.minFilter !== 1006;
    }
    function generateMipmap(target, texture, width, height) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
        }
        let internalFormat = glFormat;
        if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
        }
        if (glFormat === _gl.RGB) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
        }
        if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
        }
        if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
            extensions.get("EXT_color_buffer_float");
        }
        return internalFormat;
    }
    function filterFallback(f) {
        if (f === 1003 || f === 1004 || f === 1005) {
            return _gl.NEAREST;
        }
        return _gl.LINEAR;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) {
            _videoTextures.delete(texture);
        }
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
        }
        if (renderTarget.isWebGLCubeRenderTarget) {
            for(let i = 0; i < 6; i++){
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                if (renderTargetProperties.__webglDepthbuffer) {
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            }
        } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) {
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            if (renderTargetProperties.__webglMultisampledFramebuffer) {
                _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            }
            if (renderTargetProperties.__webglColorRenderbuffer) {
                _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            }
            if (renderTargetProperties.__webglDepthRenderbuffer) {
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
            }
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) {
            console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
        }
        textureUnits += 1;
        return textureUnit;
    }
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) {
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            } else if (image.complete === false) {
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            } else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
        [1000]: _gl.REPEAT,
        [1001]: _gl.CLAMP_TO_EDGE,
        [1002]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
        [1003]: _gl.NEAREST,
        [1004]: _gl.NEAREST_MIPMAP_NEAREST,
        [1005]: _gl.NEAREST_MIPMAP_LINEAR,
        [1006]: _gl.LINEAR,
        [1007]: _gl.LINEAR_MIPMAP_NEAREST,
        [1008]: _gl.LINEAR_MIPMAP_LINEAR
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            }
            if (texture.wrapS !== 1001 || texture.wrapT !== 1001) {
                console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== 1003 && texture.minFilter !== 1006) {
                console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
        }
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension) {
            if (texture.type === 1015 && extensions.get("OES_texture_float_linear") === null) {
                return;
            }
            if (texture.type === 1016 && (isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null) {
                return;
            }
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = _gl.TEXTURE_2D;
        if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
        if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
        initTexture(textureProperties, texture);
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
                if (texture.type === 1015) {
                    glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (texture.type === 1014) {
                    glInternalFormat = _gl.DEPTH_COMPONENT24;
                } else if (texture.type === 1020) {
                    glInternalFormat = _gl.DEPTH24_STENCIL8;
                } else {
                    glInternalFormat = _gl.DEPTH_COMPONENT16;
                }
            } else {
                if (texture.type === 1015) {
                    console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
                }
            }
            if (texture.format === 1026 && glInternalFormat === _gl.DEPTH_COMPONENT) {
                if (texture.type !== 1012 && texture.type !== 1014) {
                    console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === 1027 && glInternalFormat === _gl.DEPTH_COMPONENT) {
                glInternalFormat = _gl.DEPTH_STENCIL;
                if (texture.type !== 1020) {
                    console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            if (mipmaps.length > 0 && supportsMips) {
                for(let i = 0, il = mipmaps.length; i < il; i++){
                    mipmap = mipmaps[i];
                    state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i1 = 0, il1 = mipmaps.length; i1 < il1; i1++){
                mipmap = mipmaps[i1];
                if (texture.format !== 1023 && texture.format !== 1022) {
                    if (glFormat !== null) {
                        state.compressedTexImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    }
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else {
            if (mipmaps.length > 0 && supportsMips) {
                for(let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++){
                    mipmap = mipmaps[i2];
                    state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
                textureProperties.__maxMipLevel = 0;
            }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(textureType, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6) return;
        initTexture(textureProperties, texture);
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for(let i = 0; i < 6; i++){
            if (!isCompressed && !isDataTexture) {
                cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
            } else {
                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
            }
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
            for(let i1 = 0; i1 < 6; i1++){
                mipmaps = cubeImage[i1].mipmaps;
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    if (texture.format !== 1023 && texture.format !== 1022) {
                        if (glFormat !== null) {
                            state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i1, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else {
                            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                        }
                    } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i1, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            mipmaps = texture.mipmaps;
            for(let i2 = 0; i2 < 6; i2++){
                if (isDataTexture) {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
                    for(let j1 = 0; j1 < mipmaps.length; j1++){
                        const mipmap1 = mipmaps[j1];
                        const mipmapImage = mipmap1.image[i2].image;
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j1 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
                    for(let j2 = 0; j2 < mipmaps.length; j2++){
                        const mipmap2 = mipmaps[j2];
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap2.image[i2]);
                    }
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === 1015) {
                        glInternalFormat = _gl.DEPTH_COMPONENT32F;
                    } else if (depthTexture.type === 1014) {
                        glInternalFormat = _gl.DEPTH_COMPONENT24;
                    }
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples1 = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples1, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat1 = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples2 = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples2, glInternalFormat1, renderTarget.width, renderTarget.height);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat1, renderTarget.width, renderTarget.height);
            }
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) {
            throw new Error("Depth Texture with cube render targets is not supported");
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        }
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === 1026) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === 1027) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        } else {
            throw new Error("Unknown depthTexture format");
        }
    }
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) {
                throw new Error("target.depthTexture not supported in Cube render targets");
            }
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else {
            if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for(let i = 0; i < 6; i++){
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
                }
            } else {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (isWebGL2 && renderTarget.texture.format === 1022 && (renderTarget.texture.type === 1015 || renderTarget.texture.type === 1016)) {
            renderTarget.texture.format = RGBAFormat;
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
        }
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i = 0; i < 6; i++){
                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            }
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(renderTarget.texture.format);
                    const glType = utils.convert(renderTarget.texture.type);
                    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
                } else {
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                }
            }
        }
        if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);
            for(let i1 = 0; i1 < 6; i1++){
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i1], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i1);
            }
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
            }
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
            }
            state.bindTexture(_gl.TEXTURE_2D, null);
        }
        if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
        }
    }
    function updateRenderTargetMipmap(renderTarget) {
        const texture = renderTarget.texture;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const renderTargetProperties = properties.get(renderTarget);
                _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                const width = renderTarget.width;
                const height = renderTarget.height;
                let mask = _gl.COLOR_BUFFER_BIT;
                if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
                if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
                _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            } else {
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                warnedTexture2D = true;
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                warnedTextureCube = true;
            }
            texture = texture.texture;
        }
        setTextureCube(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === 1009) return gl.UNSIGNED_BYTE;
        if (p === 1017) return gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === 1018) return gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === 1019) return gl.UNSIGNED_SHORT_5_6_5;
        if (p === 1010) return gl.BYTE;
        if (p === 1011) return gl.SHORT;
        if (p === 1012) return gl.UNSIGNED_SHORT;
        if (p === 1013) return gl.INT;
        if (p === 1014) return gl.UNSIGNED_INT;
        if (p === 1015) return gl.FLOAT;
        if (p === 1016) {
            if (isWebGL2) return gl.HALF_FLOAT;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) {
                return extension.HALF_FLOAT_OES;
            } else {
                return null;
            }
        }
        if (p === 1021) return gl.ALPHA;
        if (p === 1022) return gl.RGB;
        if (p === 1023) return gl.RGBA;
        if (p === 1024) return gl.LUMINANCE;
        if (p === 1025) return gl.LUMINANCE_ALPHA;
        if (p === 1026) return gl.DEPTH_COMPONENT;
        if (p === 1027) return gl.DEPTH_STENCIL;
        if (p === 1028) return gl.RED;
        if (p === 1029) return gl.RED_INTEGER;
        if (p === 1030) return gl.RG;
        if (p === 1031) return gl.RG_INTEGER;
        if (p === 1032) return gl.RGB_INTEGER;
        if (p === 1033) return gl.RGBA_INTEGER;
        if (p === 33776 || p === 33777 || p === 33778 || p === 33779) {
            extension = extensions.get("WEBGL_compressed_texture_s3tc");
            if (extension !== null) {
                if (p === 33776) {
                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                }
                if (p === 33777) {
                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                }
                if (p === 33778) {
                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                }
                if (p === 33779) {
                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            } else {
                return null;
            }
        }
        if (p === 35840 || p === 35841 || p === 35842 || p === 35843) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
                if (p === 35840) {
                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                }
                if (p === 35841) {
                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                }
                if (p === 35842) {
                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                }
                if (p === 35843) {
                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            } else {
                return null;
            }
        }
        if (p === 36196) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) {
                return extension.COMPRESSED_RGB_ETC1_WEBGL;
            } else {
                return null;
            }
        }
        if (p === 37492 || p === 37496) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
                if (p === 37492) return extension.COMPRESSED_RGB8_ETC2;
                if (p === 37496) {
                    return extension.COMPRESSED_RGBA8_ETC2_EAC;
                }
            }
        }
        if (p === 37808 || p === 37809 || p === 37810 || p === 37811 || p === 37812 || p === 37813 || p === 37814 || p === 37815 || p === 37816 || p === 37817 || p === 37818 || p === 37819 || p === 37820 || p === 37821 || p === 37840 || p === 37841 || p === 37842 || p === 37843 || p === 37844 || p === 37845 || p === 37846 || p === 37847 || p === 37848 || p === 37849 || p === 37850 || p === 37851 || p === 37852 || p === 37853) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
                return p;
            } else {
                return null;
            }
        }
        if (p === 36492) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
                return p;
            } else {
                return null;
            }
        }
        if (p === 1020) {
            if (isWebGL2) return gl.UNSIGNED_INT_24_8;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) {
                return extension.UNSIGNED_INT_24_8_WEBGL;
            } else {
                return null;
            }
        }
    }
    return {
        convert: convert
    };
}
function ArrayCamera(array) {
    PerspectiveCamera.call(this);
    this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
});
function Group() {
    Object3D.call(this);
    this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
});
function WebXRController() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
}
Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getHandSpace: function() {
        if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = [];
            this._hand.inputState = {
                pinching: false
            };
            if (window.XRHand) {
                for(let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++){
                    const joint = new Group();
                    joint.matrixAutoUpdate = false;
                    joint.visible = false;
                    this._hand.joints.push(joint);
                    this._hand.add(joint);
                }
            }
        }
        return this._hand;
    },
    getTargetRaySpace: function() {
        if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
        }
        return this._targetRay;
    },
    getGripSpace: function() {
        if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
        }
        return this._grip;
    },
    dispatchEvent: function(event) {
        if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
        }
        if (this._grip !== null) {
            this._grip.dispatchEvent(event);
        }
        if (this._hand !== null) {
            this._hand.dispatchEvent(event);
        }
        return this;
    },
    disconnect: function(inputSource) {
        this.dispatchEvent({
            type: "disconnected",
            data: inputSource
        });
        if (this._targetRay !== null) {
            this._targetRay.visible = false;
        }
        if (this._grip !== null) {
            this._grip.visible = false;
        }
        if (this._hand !== null) {
            this._hand.visible = false;
        }
        return this;
    },
    update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource) {
            if (hand && inputSource.hand) {
                handPose = true;
                for(let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++){
                    if (inputSource.hand[i]) {
                        const jointPose = frame.getJointPose(inputSource.hand[i], referenceSpace);
                        const joint = hand.joints[i];
                        if (jointPose !== null) {
                            joint.matrix.fromArray(jointPose.transform.matrix);
                            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                            joint.jointRadius = jointPose.radius;
                        }
                        joint.visible = jointPose !== null;
                        const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
                        const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
                        const distance = indexTip.position.distanceTo(thumbTip.position);
                        if (hand.inputState.pinching && distance > 0.02 + 0.005) {
                            hand.inputState.pinching = false;
                            this.dispatchEvent({
                                type: "pinchend",
                                handedness: inputSource.handedness,
                                target: this
                            });
                        } else if (!hand.inputState.pinching && distance <= 0.02 - 0.005) {
                            hand.inputState.pinching = true;
                            this.dispatchEvent({
                                type: "pinchstart",
                                handedness: inputSource.handedness,
                                target: this
                            });
                        }
                    }
                }
            } else {
                if (targetRay !== null) {
                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                    if (inputPose !== null) {
                        targetRay.matrix.fromArray(inputPose.transform.matrix);
                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    }
                }
                if (grip !== null && inputSource.gripSpace) {
                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                    if (gripPose !== null) {
                        grip.matrix.fromArray(gripPose.transform.matrix);
                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    }
                }
            }
        }
        if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
            grip.visible = gripPose !== null;
        }
        if (hand !== null) {
            hand.visible = handPose !== null;
        }
        return this;
    }
});
function WebXRManager(renderer, gl) {
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1.0;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [
        cameraL,
        cameraR
    ];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getGripSpace();
    };
    this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getHandSpace();
    };
    function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) {
            controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
            });
        }
    }
    function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget());
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({
            type: "sessionend"
        });
    }
    function onRequestReferenceSpace(value) {
        referenceSpace = value;
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({
            type: "sessionstart"
        });
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
    };
    this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
    };
    this.getReferenceSpace = function() {
        return referenceSpace;
    };
    this.getSession = function() {
        return session;
    };
    this.setSession = function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener("select", onSessionEvent);
            session.addEventListener("selectstart", onSessionEvent);
            session.addEventListener("selectend", onSessionEvent);
            session.addEventListener("squeeze", onSessionEvent);
            session.addEventListener("squeezestart", onSessionEvent);
            session.addEventListener("squeezeend", onSessionEvent);
            session.addEventListener("end", onSessionEnd);
            const attributes = gl.getContextAttributes();
            if (attributes.xrCompatible !== true) {
                gl.makeXRCompatible();
            }
            const layerInit = {
                antialias: attributes.antialias,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor: framebufferScaleFactor
            };
            const baseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({
                baseLayer: baseLayer
            });
            session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
            session.addEventListener("inputsourceschange", updateInputSources);
        }
    };
    function updateInputSources(event) {
        const inputSources = session.inputSources;
        for(let i = 0; i < controllers.length; i++){
            inputSourcesMap.set(inputSources[i], controllers[i]);
        }
        for(let i1 = 0; i1 < event.removed.length; i1++){
            const inputSource = event.removed[i1];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
                controller.dispatchEvent({
                    type: "disconnected",
                    data: inputSource
                });
                inputSourcesMap.delete(inputSource);
            }
        }
        for(let i2 = 0; i2 < event.added.length; i2++){
            const inputSource1 = event.added[i2];
            const controller1 = inputSourcesMap.get(inputSource1);
            if (controller1) {
                controller1.dispatchEvent({
                    type: "connected",
                    data: inputSource1
                });
            }
        }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL, cameraR) {
        cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL.projectionMatrix.elements;
        const projR = cameraR.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
        if (parent === null) {
            camera.matrixWorld.copy(camera.matrix);
        } else {
            camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
    this.getCamera = function(camera) {
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for(let i = 0; i < cameras.length; i++){
            updateCamera(cameras[i], parent);
        }
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++){
            children[i1].updateMatrixWorld(true);
        }
        if (cameras.length === 2) {
            setProjectionFromUnion(cameraVR, cameraL, cameraR);
        } else {
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
        return cameraVR;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
            const views = pose.views;
            const baseLayer = session.renderState.baseLayer;
            renderer.setFramebuffer(baseLayer.framebuffer);
            let cameraVRNeedsUpdate = false;
            if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
            }
            for(let i = 0; i < views.length; i++){
                const view = views[i];
                const viewport = baseLayer.getViewport(view);
                const camera = cameras[i];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                    cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                    cameraVR.cameras.push(camera);
                }
            }
        }
        const inputSources = session.inputSources;
        for(let i1 = 0; i1 < controllers.length; i1++){
            const controller = controllers[i1];
            const inputSource = inputSources[i1];
            controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {};
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
        }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
        if (material.isMeshBasicMaterial) {
            refreshUniformsCommon(uniforms, material);
        } else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) {
                refreshUniformsPhysical(uniforms, material);
            } else {
                refreshUniformsStandard(uniforms, material);
            }
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) {
                refreshUniformsDash(uniforms, material);
            }
        } else if (material.isPointsMaterial) {
            refreshUniformsPoints(uniforms, material, pixelRatio, height);
        } else if (material.isSpriteMaterial) {
            refreshUniformsSprites(uniforms, material);
        } else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) {
            material.uniformsNeedUpdate = false;
        }
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) {
            uniforms.diffuse.value.copy(material.color);
        }
        if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        }
        if (material.map) {
            uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
        }
        if (material.specularMap) {
            uniforms.specularMap.value = material.specularMap;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) {
                uniforms.maxMipLevel.value = maxMipLevel;
            }
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        let uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
        } else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
        } else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
        } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
        } else if (material.clearcoatMap) {
            uvScaleMap = material.clearcoatMap;
        } else if (material.clearcoatNormalMap) {
            uvScaleMap = material.clearcoatNormalMap;
        } else if (material.clearcoatRoughnessMap) {
            uvScaleMap = material.clearcoatRoughnessMap;
        }
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.isWebGLRenderTarget) {
                uvScaleMap = uvScaleMap.texture;
            }
            if (uvScaleMap.matrixAutoUpdate === true) {
                uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        let uv2ScaleMap;
        if (material.aoMap) {
            uv2ScaleMap = material.aoMap;
        } else if (material.lightMap) {
            uv2ScaleMap = material.lightMap;
        }
        if (uv2ScaleMap !== undefined) {
            if (uv2ScaleMap.isWebGLRenderTarget) {
                uv2ScaleMap = uv2ScaleMap.texture;
            }
            if (uv2ScaleMap.matrixAutoUpdate === true) {
                uv2ScaleMap.updateMatrix();
            }
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) {
            uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
        }
        let uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) {
                uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) {
            uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
        }
        let uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) {
                uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 1e-4);
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === 1) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === 1) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) {
            uniforms.gradientMap.value = material.gradientMap;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === 1) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === 1) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
        }
        if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === 1) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === 1) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMapIntensity.value = material.envMapIntensity;
        }
    }
    function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen) uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) {
            uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
            uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === 1) {
                uniforms.clearcoatNormalScale.value.negate();
            }
        }
        uniforms.transmission.value = material.transmission;
        if (material.transmissionMap) {
            uniforms.transmissionMap.value = material.transmissionMap;
        }
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) {
            uniforms.matcap.value = material.matcap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === 1) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === 1) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === 1) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === 1) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
function WebGLRenderer(parameters) {
    parameters = parameters || {};
    const _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    this.domElement = _canvas;
    this.debug = {
        checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2.0;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1.0;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    const _this = this;
    let _isContextLost = false;
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    let _currentArrayCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas.width;
    let _height = _canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _projScreenMatrix = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
        for(let i = 0; i < contextNames.length; i++){
            const contextName = contextNames[i];
            const context = _canvas.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        _canvas.addEventListener("webglcontextlost", onContextLost, false);
        _canvas.addEventListener("webglcontextrestored", onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                "webgl2",
                "webgl",
                "experimental-webgl"
            ];
            if (_this.isWebGL1Renderer === true) {
                contextNames.shift();
            }
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) {
                    throw new Error("Error creating WebGL context with your selected attributes.");
                } else {
                    throw new Error("Error creating WebGL context.");
                }
            }
        }
        if (_gl.getShaderPrecisionFormat === undefined) {
            _gl.getShaderPrecisionFormat = function() {
                return {
                    "rangeMin": 1,
                    "rangeMax": 1,
                    "precision": 1
                };
            };
        }
    } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        if (capabilities.isWebGL2 === false) {
            extensions.get("WEBGL_depth_texture");
            extensions.get("OES_texture_float");
            extensions.get("OES_texture_half_float");
            extensions.get("OES_texture_half_float_linear");
            extensions.get("OES_standard_derivatives");
            extensions.get("OES_element_index_uint");
            extensions.get("OES_vertex_array_object");
            extensions.get("ANGLE_instanced_arrays");
        }
        extensions.get("OES_texture_float_linear");
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        attributes = new WebGLAttributes(_gl, capabilities);
        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(properties);
        renderLists = new WebGLRenderLists(properties);
        renderStates = new WebGLRenderStates();
        background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        if (target === undefined) {
            console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
            target = new Vector2();
        }
        return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
        }
        _width = width;
        _height = height;
        _canvas.width = Math.floor(width * _pixelRatio);
        _canvas.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
            _canvas.style.width = width + "px";
            _canvas.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
        if (target === undefined) {
            console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
            target = new Vector2();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas.width = Math.floor(width * pixelRatio);
        _canvas.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
        if (target === undefined) {
            console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
            target = new Vector4();
        }
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
        if (x.isVector4) {
            _viewport.set(x.x, x.y, x.z, x.w);
        } else {
            _viewport.set(x, y, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
        if (x.isVector4) {
            _scissor.set(x.x, x.y, x.z, x.w);
        } else {
            _scissor.set(x, y, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(__boolean) {
        state.setScissorTest(_scissorTest = __boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    this.getClearColor = function() {
        return background.getClearColor();
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
        let bits = 0;
        if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    this.dispose = function() {
        _canvas.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
    };
    function onContextLost(event) {
        event.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        const programInfo = properties.get(material).program;
        if (programInfo !== undefined) {
            programCache.releaseProgram(programInfo);
        }
    }
    function renderObjectImmediate(object, program) {
        object.render(function(object) {
            _this.renderBufferImmediate(object, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) {
            buffers.position = _gl.createBuffer();
        }
        if (object.hasNormals && !buffers.normal) {
            buffers.normal = _gl.createBuffer();
        }
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene;
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        let index = geometry.index;
        const position = geometry.attributes.position;
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) {
            return;
        }
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) {
            morphtargets.update(object, geometry, material, program);
        }
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
            } else {
                renderer.setMode(_gl.TRIANGLES);
            }
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
                renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
                renderer.setMode(_gl.LINE_LOOP);
            } else {
                renderer.setMode(_gl.LINE_STRIP);
            }
        } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
        } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
        }
        if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else {
            renderer.render(drawStart, drawCount);
        }
    };
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) {
                    currentRenderState.pushShadow(object);
                }
            }
        });
        currentRenderState.setupLights(camera);
        const compiled = new WeakMap();
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) {
                    for(let i = 0; i < material.length; i++){
                        const material2 = material[i];
                        if (compiled.has(material2) === false) {
                            initMaterial(material2, scene, object);
                            compiled.set(material2);
                        }
                    }
                } else if (compiled.has(material) === false) {
                    initMaterial(material, scene, object);
                    compiled.set(material);
                }
            }
        });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (xr.isPresenting) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined") animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    this.render = function(scene, camera) {
        let renderTarget, forceClear;
        if (arguments[2] !== undefined) {
            console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
            renderTarget = arguments[2];
        }
        if (arguments[3] !== undefined) {
            console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
            forceClear = arguments[3];
        }
        if (camera !== undefined && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
        }
        if (_isContextLost === true) return;
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
            camera = xr.getCamera(camera);
        }
        if (scene.isScene === true) {
            scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        }
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled === true) clipping.endShadows();
        if (this.info.autoReset === true) this.info.reset();
        if (renderTarget !== undefined) {
            this.setRenderTarget(renderTarget);
        }
        background.render(currentRenderList, scene, camera, forceClear);
        const opaqueObjects = currentRenderList.opaque;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length > 0) {
            renderObjects(transparentObjects, scene, camera);
        }
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        if (_currentRenderTarget !== null) {
            textures.updateRenderTargetMipmap(_currentRenderTarget);
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        currentRenderList = null;
        currentRenderState = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) {
                groupOrder = object.renderOrder;
            } else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) {
                    currentRenderState.pushShadow(object);
                }
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) {
                        _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) {
                        currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                    }
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) {
                    _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                }
                currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) {
                        _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    const geometry1 = objects.update(object);
                    const material1 = object.material;
                    if (Array.isArray(material1)) {
                        const groups = geometry1.groups;
                        for(let i = 0, l = groups.length; i < l; i++){
                            const group = groups[i];
                            const groupMaterial = material1[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                currentRenderList.push(object, geometry1, groupMaterial, groupOrder, _vector3.z, group);
                            }
                        }
                    } else if (material1.visible) {
                        currentRenderList.push(object, geometry1, material1, groupOrder, _vector3.z, null);
                    }
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l1 = children.length; i1 < l1; i1++){
            projectObject(children[i1], camera, groupOrder, sortObjects);
        }
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i = 0, l = renderList.length; i < l; i++){
            const renderItem = renderList[i];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                _currentArrayCamera = camera;
                const cameras = camera.cameras;
                for(let j = 0, jl = cameras.length; j < jl; j++){
                    const camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        state.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLights(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else {
                _currentArrayCamera = null;
                renderObject(object, scene, camera, geometry, material, group);
            }
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else {
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        }
        object.onAfterRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }
    function initMaterial(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters);
        let program = materialProperties.program;
        let programChange = true;
        if (program === undefined) {
            material.addEventListener("dispose", onMaterialDispose);
        } else if (program.cacheKey !== programCacheKey) {
            releaseMaterialProgramReference(material);
        } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
            programChange = false;
        } else if (parameters.shaderID !== undefined) {
            const environment = material.isMeshStandardMaterial ? scene.environment : null;
            materialProperties.envMap = cubemaps.get(material.envMap || environment);
            return;
        } else {
            programChange = false;
        }
        if (programChange) {
            parameters.uniforms = programCache.getUniforms(material);
            material.onBeforeCompile(parameters, _this);
            program = programCache.acquireProgram(parameters, programCacheKey);
            materialProperties.program = program;
            materialProperties.uniforms = parameters.uniforms;
            materialProperties.outputEncoding = parameters.outputEncoding;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = clipping.numPlanes;
            materialProperties.numIntersection = clipping.numIntersection;
            uniforms.clippingPlanes = clipping.uniform;
        }
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        const progUniforms = materialProperties.program.getUniforms();
        const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material.envMap || environment);
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                clipping.setState(material, camera, useCache);
            }
        }
        if (material.version === materialProperties.__version) {
            if (material.fog && materialProperties.fog !== fog) {
                initMaterial(material, scene, object);
            } else if (materialProperties.environment !== environment) {
                initMaterial(material, scene, object);
            } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
                initMaterial(material, scene, object);
            } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
                initMaterial(material, scene, object);
            } else if (materialProperties.outputEncoding !== encoding) {
                initMaterial(material, scene, object);
            } else if (materialProperties.envMap !== envMap) {
                initMaterial(material, scene, object);
            }
        } else {
            initMaterial(material, scene, object);
            materialProperties.__version = material.version;
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) {
                p_uniforms.setValue(_gl, "logDepthBufFC", 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
            }
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) {
                    uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
                p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
                p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
        }
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
                const bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === undefined) {
                        let size = Math.sqrt(bones.length * 4);
                        size = MathUtils.ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        const boneMatrices = new Float32Array(size * size * 4);
                        boneMatrices.set(skeleton.boneMatrices);
                        const boneTexture = new DataTexture(boneMatrices, size, size, 1023, 1015);
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size;
                    }
                    p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                } else {
                    p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
                }
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog) {
                materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
        }
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);
        }
        _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderList = function() {
        return currentRenderList;
    };
    this.setRenderList = function(renderList) {
        currentRenderList = renderList;
    };
    this.getRenderState = function() {
        return currentRenderState;
    };
    this.setRenderState = function(renderState) {
        currentRenderState = renderState;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
            textures.setupRenderTarget(renderTarget);
        }
        let framebuffer = _framebuffer;
        let isCube = false;
        if (renderTarget) {
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) {
                framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
                framebuffer = __webglFramebuffer;
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
            framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
            let restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                }
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                        _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                    }
                } else {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                }
            } finally{
                if (restore) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                }
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === undefined) level = 0;
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        const glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        if (level === undefined) level = 0;
        const width = srcTexture.image.width;
        const height = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        } else {
            if (srcTexture.isCompressedTexture) {
                _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            } else {
                _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
            }
        }
        if (level === 0 && dstTexture.generateMipmaps) {
            _gl.generateMipmap(_gl.TEXTURE_2D);
        }
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }));
    }
}
function WebGL1Renderer(parameters) {
    WebGLRenderer.call(this, parameters);
}
WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
    constructor: WebGL1Renderer,
    isWebGL1Renderer: true
});
class Fog {
    constructor(color, near, far){
        Object.defineProperty(this, "isFog", {
            value: true
        });
        this.name = "";
        this.color = new Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
    }
    clone() {
        return new Fog(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
}
class Scene extends Object3D {
    constructor(){
        super();
        Object.defineProperty(this, "isScene", {
            value: true
        });
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) {
            this.environment = source.environment.clone();
        }
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) {
            this.overrideMaterial = source.overrideMaterial.clone();
        }
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.background !== null) {
            data.object.background = this.background.toJSON(meta);
        }
        if (this.environment !== null) {
            data.object.environment = this.environment.toJSON(meta);
        }
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
}
function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
    this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {},
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i = 0, l = this.stride; i < l; i++){
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    clone: function(data) {
        if (data.arrayBuffers === undefined) {
            data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === undefined) {
            this.array.buffer._uuid = MathUtils.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    toJSON: function(data) {
        if (data.arrayBuffers === undefined) {
            data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === undefined) {
            this.array.buffer._uuid = MathUtils.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        }
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
});
const _vector6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    },
    needsUpdate: {
        set: function(value) {
            this.data.needsUpdate = value;
        }
    }
});
Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
        for(let i = 0, l = this.data.count; i < l; i++){
            _vector6.x = this.getX(i);
            _vector6.y = this.getY(i);
            _vector6.z = this.getZ(i);
            _vector6.applyMatrix4(m);
            this.setXYZ(i, _vector6.x, _vector6.y, _vector6.z);
        }
        return this;
    },
    setX: function(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    },
    setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    },
    setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    },
    setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    },
    getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    },
    clone: function(data) {
        if (data === undefined) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for(let i = 0; i < this.count; i++){
                const index = i * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++){
                    array.push(this.data.array[index + j]);
                }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) {
                data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    },
    toJSON: function(data) {
        if (data === undefined) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for(let i = 0; i < this.count; i++){
                const index = i * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++){
                    array.push(this.data.array[index + j]);
                }
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            if (data.interleavedBuffers === undefined) {
                data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
});
function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
let _geometry;
const _intersectPoint = new Vector3();
const _worldScale = new Vector3();
const _mvPosition = new Vector3();
const _alignedPosition = new Vector2();
const _rotatedPosition = new Vector2();
const _viewWorldMatrix = new Matrix4();
const _vA1 = new Vector3();
const _vB1 = new Vector3();
const _vC1 = new Vector3();
const _uvA1 = new Vector2();
const _uvB1 = new Vector2();
const _uvC1 = new Vector2();
function Sprite(material) {
    Object3D.call(this);
    this.type = "Sprite";
    if (_geometry === undefined) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1, 
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function(raycaster, intersects) {
        if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
        }
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA1.set(0, 0);
        _uvB1.set(1, 0);
        _uvC1.set(1, 1);
        let intersect = raycaster.ray.intersectTriangle(_vA1, _vB1, _vC1, false, _intersectPoint);
        if (intersect === null) {
            transformVertex(_vB1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB1.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA1, _vC1, _vB1, false, _intersectPoint);
            if (intersect === null) {
                return;
            }
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA1, _vB1, _vC1, _uvA1, _uvB1, _uvC1, new Vector2()),
            face: null,
            object: this
        });
    },
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
});
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== undefined) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
        _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v14 = new Vector3();
const _v22 = new Vector3();
function LOD() {
    Object3D.call(this);
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
    this.autoUpdate = true;
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for(let i = 0, l = levels.length; i < l; i++){
            const level = levels[i];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    },
    addLevel: function(object, distance) {
        if (distance === undefined) distance = 0;
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) {
                break;
            }
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    },
    getCurrentLevel: function() {
        return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i, l;
            for(i = 1, l = levels.length; i < l; i++){
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        }
        return null;
    },
    raycast: function(raycaster, intersects) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v14.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v14);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
    },
    update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v14.setFromMatrixPosition(camera.matrixWorld);
            _v22.setFromMatrixPosition(this.matrixWorld);
            const distance = _v14.distanceTo(_v22) / camera.zoom;
            levels[0].object.visible = true;
            let i, l;
            for(i = 1, l = levels.length; i < l; i++){
                if (distance >= levels[i].distance) {
                    levels[i - 1].object.visible = false;
                    levels[i].object.visible = true;
                } else {
                    break;
                }
            }
            this._currentLevel = i - 1;
            for(; i < l; i++){
                levels[i].object.visible = false;
            }
        }
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i = 0, l = levels.length; i < l; i++){
            const level = levels[i];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) {
        console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    Mesh.call(this, geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    },
    bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i = 0, l = skinWeight.count; i < l; i++){
            vector.x = skinWeight.getX(i);
            vector.y = skinWeight.getY(i);
            vector.z = skinWeight.getZ(i);
            vector.w = skinWeight.getW(i);
            const scale = 1.0 / vector.manhattanLength();
            if (scale !== Infinity) {
                vector.multiplyScalar(scale);
            } else {
                vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
        }
    },
    updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === "attached") {
            this.bindMatrixInverse.getInverse(this.matrixWorld);
        } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.getInverse(this.bindMatrix);
        } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
    },
    boneTransform: function() {
        const basePosition = new Vector3();
        const skinIndex = new Vector4();
        const skinWeight = new Vector4();
        const vector = new Vector3();
        const matrix = new Matrix4();
        return function(index, target) {
            const skeleton = this.skeleton;
            const geometry = this.geometry;
            skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
            skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
            basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
            target.set(0, 0, 0);
            for(let i = 0; i < 4; i++){
                const weight = skinWeight.getComponent(i);
                if (weight !== 0) {
                    const boneIndex = skinIndex.getComponent(i);
                    matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                    target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
                }
            }
            return target.applyMatrix4(this.bindMatrixInverse);
        };
    }()
});
const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
function Skeleton(bones, boneInverses) {
    bones = bones || [];
    this.bones = bones.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    this.frame = -1;
    if (boneInverses === undefined) {
        this.calculateInverses();
    } else {
        if (this.bones.length === boneInverses.length) {
            this.boneInverses = boneInverses.slice(0);
        } else {
            console.warn("THREE.Skeleton boneInverses is the wrong length.");
            this.boneInverses = [];
            for(let i = 0, il = this.bones.length; i < il; i++){
                this.boneInverses.push(new Matrix4());
            }
        }
    }
}
Object.assign(Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for(let i = 0, il = this.bones.length; i < il; i++){
            const inverse = new Matrix4();
            if (this.bones[i]) {
                inverse.getInverse(this.bones[i].matrixWorld);
            }
            this.boneInverses.push(inverse);
        }
    },
    pose: function() {
        for(let i = 0, il = this.bones.length; i < il; i++){
            const bone = this.bones[i];
            if (bone) {
                bone.matrixWorld.getInverse(this.boneInverses[i]);
            }
        }
        for(let i1 = 0, il1 = this.bones.length; i1 < il1; i1++){
            const bone1 = this.bones[i1];
            if (bone1) {
                if (bone1.parent && bone1.parent.isBone) {
                    bone1.matrix.getInverse(bone1.parent.matrixWorld);
                    bone1.matrix.multiply(bone1.matrixWorld);
                } else {
                    bone1.matrix.copy(bone1.matrixWorld);
                }
                bone1.matrix.decompose(bone1.position, bone1.quaternion, bone1.scale);
            }
        }
    },
    update: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        for(let i = 0, il = bones.length; i < il; i++){
            const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
            _offsetMatrix.toArray(boneMatrices, i * 16);
        }
        if (boneTexture !== undefined) {
            boneTexture.needsUpdate = true;
        }
    },
    clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
        for(let i = 0, il = this.bones.length; i < il; i++){
            const bone = this.bones[i];
            if (bone.name === name) {
                return bone;
            }
        }
        return undefined;
    },
    dispose: function() {
        if (this.boneTexture) {
            this.boneTexture.dispose();
            this.boneTexture = undefined;
        }
    }
});
function Bone() {
    Object3D.call(this);
    this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
});
const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        this.count = source.count;
        return this;
    },
    setColorAt: function(index, color) {
        if (this.instanceColor === null) {
            this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
        }
        color.toArray(this.instanceColor.array, index * 3);
    },
    getMatrixAt: function(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster, intersects) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for(let i = 0, l = _instanceIntersects.length; i < l; i++){
                const intersect = _instanceIntersects[i];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    },
    setMatrixAt: function(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {}
});
function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new Color(0xffffff);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
};
const _start = new Vector3();
const _end = new Vector3();
const _inverseMatrix1 = new Matrix4();
const _ray1 = new Ray();
const _sphere2 = new Sphere();
function Line(geometry, material, mode) {
    if (mode === 1) {
        console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    }
    Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial();
    this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i = 1, l = positionAttribute.count; i < l; i++){
                    _start.fromBufferAttribute(positionAttribute, i - 1);
                    _end.fromBufferAttribute(positionAttribute, i);
                    lineDistances[i] = lineDistances[i - 1];
                    lineDistances[i] += _start.distanceTo(_end);
                }
                geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const lineDistances1 = geometry.lineDistances;
            lineDistances1[0] = 0;
            for(let i1 = 1, l1 = vertices.length; i1 < l1; i1++){
                lineDistances1[i1] = lineDistances1[i1 - 1];
                lineDistances1[i1] += vertices[i1 - 1].distanceTo(vertices[i1]);
            }
        }
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere2.copy(geometry.boundingSphere);
        _sphere2.applyMatrix4(matrixWorld);
        _sphere2.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere2) === false) return;
        _inverseMatrix1.getInverse(matrixWorld);
        _ray1.copy(raycaster.ray).applyMatrix4(_inverseMatrix1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const indices = index.array;
                for(let i = 0, l = indices.length - 1; i < l; i += step){
                    const a = indices[i];
                    const b = indices[i + 1];
                    vStart.fromBufferAttribute(positionAttribute, a);
                    vEnd.fromBufferAttribute(positionAttribute, b);
                    const distSq = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else {
                for(let i1 = 0, l1 = positionAttribute.count - 1; i1 < l1; i1 += step){
                    vStart.fromBufferAttribute(positionAttribute, i1);
                    vEnd.fromBufferAttribute(positionAttribute, i1 + 1);
                    const distSq1 = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq1 > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    const distance1 = raycaster.ray.origin.distanceTo(interRay);
                    if (distance1 < raycaster.near || distance1 > raycaster.far) continue;
                    intersects.push({
                        distance: distance1,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i1,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const nbVertices = vertices.length;
            for(let i2 = 0; i2 < nbVertices - 1; i2 += step){
                const distSq2 = _ray1.distanceSqToSegment(vertices[i2], vertices[i2 + 1], interRay, interSegment);
                if (distSq2 > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance2 = raycaster.ray.origin.distanceTo(interRay);
                if (distance2 < raycaster.near || distance2 > raycaster.far) continue;
                intersects.push({
                    distance: distance2,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i2,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) {
                console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
        }
    }
});
const _start1 = new Vector3();
const _end1 = new Vector3();
function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i = 0, l = positionAttribute.count; i < l; i += 2){
                    _start1.fromBufferAttribute(positionAttribute, i);
                    _end1.fromBufferAttribute(positionAttribute, i + 1);
                    lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                    lineDistances[i + 1] = lineDistances[i] + _start1.distanceTo(_end1);
                }
                geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const lineDistances1 = geometry.lineDistances;
            for(let i1 = 0, l1 = vertices.length; i1 < l1; i1 += 2){
                _start1.copy(vertices[i1]);
                _end1.copy(vertices[i1 + 1]);
                lineDistances1[i1] = i1 === 0 ? 0 : lineDistances1[i1 - 1];
                lineDistances1[i1 + 1] = lineDistances1[i1] + _start1.distanceTo(_end1);
            }
        }
        return this;
    }
});
function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
});
function PointsMaterial(parameters) {
    Material.call(this);
    this.type = "PointsMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
const _inverseMatrix2 = new Matrix4();
const _ray2 = new Ray();
const _sphere3 = new Sphere();
const _position1 = new Vector3();
function Points(geometry, material) {
    Object3D.call(this);
    this.type = "Points";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial();
    this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere3.copy(geometry.boundingSphere);
        _sphere3.applyMatrix4(matrixWorld);
        _sphere3.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere3) === false) return;
        _inverseMatrix2.getInverse(matrixWorld);
        _ray2.copy(raycaster.ray).applyMatrix4(_inverseMatrix2);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const indices = index.array;
                for(let i = 0, il = indices.length; i < il; i++){
                    const a = indices[i];
                    _position1.fromBufferAttribute(positionAttribute, a);
                    testPoint(_position1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else {
                for(let i1 = 0, l = positionAttribute.count; i1 < l; i1++){
                    _position1.fromBufferAttribute(positionAttribute, i1);
                    testPoint(_position1, i1, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            }
        } else {
            const vertices = geometry.vertices;
            for(let i2 = 0, l1 = vertices.length; i2 < l1; i2++){
                testPoint(vertices[i2], i2, localThresholdSq, matrixWorld, raycaster, intersects, this);
            }
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) {
                console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
        }
    }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = _ray2.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector3();
        _ray2.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
        scope.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
        video.requestVideoFrameCallback(updateVideo);
    }
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
        }
    }
});
function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== 1026 && format !== 1027) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === undefined && format === 1026) type = UnsignedShortType;
    if (type === undefined && format === 1027) {
        type = UnsignedInt248Type;
    }
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width,
        height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
let _geometryId = 0;
const _m13 = new Matrix4();
const _obj1 = new Object3D();
const _offset1 = new Vector3();
function Geometry() {
    Object.defineProperty(this, "id", {
        value: _geometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function(matrix) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for(let i = 0, il = this.vertices.length; i < il; i++){
            const vertex = this.vertices[i];
            vertex.applyMatrix4(matrix);
        }
        for(let i1 = 0, il1 = this.faces.length; i1 < il1; i1++){
            const face = this.faces[i1];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for(let j = 0, jl = face.vertexNormals.length; j < jl; j++){
                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function(angle) {
        _m13.makeRotationX(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateY: function(angle) {
        _m13.makeRotationY(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateZ: function(angle) {
        _m13.makeRotationZ(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    translate: function(x, y, z) {
        _m13.makeTranslation(x, y, z);
        this.applyMatrix4(_m13);
        return this;
    },
    scale: function(x, y, z) {
        _m13.makeScale(x, y, z);
        this.applyMatrix4(_m13);
        return this;
    },
    lookAt: function(vector) {
        _obj1.lookAt(vector);
        _obj1.updateMatrix();
        this.applyMatrix4(_obj1.matrix);
        return this;
    },
    fromBufferGeometry: function(geometry) {
        const scope = this;
        const index = geometry.index !== null ? geometry.index : undefined;
        const attributes = geometry.attributes;
        if (attributes.position === undefined) {
            console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
            return this;
        }
        const position = attributes.position;
        const normal = attributes.normal;
        const color = attributes.color;
        const uv = attributes.uv;
        const uv2 = attributes.uv2;
        if (uv2 !== undefined) this.faceVertexUvs[1] = [];
        for(let i = 0; i < position.count; i++){
            scope.vertices.push(new Vector3().fromBufferAttribute(position, i));
            if (color !== undefined) {
                scope.colors.push(new Color().fromBufferAttribute(color, i));
            }
        }
        function addFace(a, b, c, materialIndex) {
            const vertexColors = color === undefined ? [] : [
                scope.colors[a].clone(),
                scope.colors[b].clone(),
                scope.colors[c].clone(), 
            ];
            const vertexNormals = normal === undefined ? [] : [
                new Vector3().fromBufferAttribute(normal, a),
                new Vector3().fromBufferAttribute(normal, b),
                new Vector3().fromBufferAttribute(normal, c), 
            ];
            const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
            scope.faces.push(face);
            if (uv !== undefined) {
                scope.faceVertexUvs[0].push([
                    new Vector2().fromBufferAttribute(uv, a),
                    new Vector2().fromBufferAttribute(uv, b),
                    new Vector2().fromBufferAttribute(uv, c), 
                ]);
            }
            if (uv2 !== undefined) {
                scope.faceVertexUvs[1].push([
                    new Vector2().fromBufferAttribute(uv2, a),
                    new Vector2().fromBufferAttribute(uv2, b),
                    new Vector2().fromBufferAttribute(uv2, c), 
                ]);
            }
        }
        const groups = geometry.groups;
        if (groups.length > 0) {
            for(let i1 = 0; i1 < groups.length; i1++){
                const group = groups[i1];
                const start = group.start;
                const count = group.count;
                for(let j = start, jl = start + count; j < jl; j += 3){
                    if (index !== undefined) {
                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
                    } else {
                        addFace(j, j + 1, j + 2, group.materialIndex);
                    }
                }
            }
        } else {
            if (index !== undefined) {
                for(let i2 = 0; i2 < index.count; i2 += 3){
                    addFace(index.getX(i2), index.getX(i2 + 1), index.getX(i2 + 2));
                }
            } else {
                for(let i3 = 0; i3 < position.count; i3 += 3){
                    addFace(i3, i3 + 1, i3 + 2);
                }
            }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset1).negate();
        this.translate(_offset1.x, _offset1.y, _offset1.z);
        return this;
    },
    normalize: function() {
        this.computeBoundingSphere();
        const center = this.boundingSphere.center;
        const radius = this.boundingSphere.radius;
        const s = radius === 0 ? 1 : 1.0 / radius;
        const matrix = new Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix4(matrix);
        return this;
    },
    computeFaceNormals: function() {
        const cb = new Vector3(), ab = new Vector3();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vA = this.vertices[face.a];
            const vB = this.vertices[face.b];
            const vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === undefined) areaWeighted = true;
        const vertices = new Array(this.vertices.length);
        for(let v = 0, vl = this.vertices.length; v < vl; v++){
            vertices[v] = new Vector3();
        }
        if (areaWeighted) {
            const cb = new Vector3(), ab = new Vector3();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vA = this.vertices[face.a];
                const vB = this.vertices[face.b];
                const vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        } else {
            this.computeFaceNormals();
            for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                const face1 = this.faces[f1];
                vertices[face1.a].add(face1.normal);
                vertices[face1.b].add(face1.normal);
                vertices[face1.c].add(face1.normal);
            }
        }
        for(let v1 = 0, vl1 = this.vertices.length; v1 < vl1; v1++){
            vertices[v1].normalize();
        }
        for(let f2 = 0, fl2 = this.faces.length; f2 < fl2; f2++){
            const face2 = this.faces[f2];
            const vertexNormals = face2.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices[face2.a]);
                vertexNormals[1].copy(vertices[face2.b]);
                vertexNormals[2].copy(vertices[face2.c]);
            } else {
                vertexNormals[0] = vertices[face2.a].clone();
                vertexNormals[1] = vertices[face2.b].clone();
                vertexNormals[2] = vertices[face2.c].clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = true;
        }
    },
    computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            } else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = true;
        }
    },
    computeMorphNormals: function() {
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            if (!face.__originalFaceNormal) {
                face.__originalFaceNormal = face.normal.clone();
            } else {
                face.__originalFaceNormal.copy(face.normal);
            }
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for(let i = 0, il = face.vertexNormals.length; i < il; i++){
                if (!face.__originalVertexNormals[i]) {
                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                } else {
                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                }
            }
        }
        const tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for(let i1 = 0, il1 = this.morphTargets.length; i1 < il1; i1++){
            if (!this.morphNormals[i1]) {
                this.morphNormals[i1] = {};
                this.morphNormals[i1].faceNormals = [];
                this.morphNormals[i1].vertexNormals = [];
                const dstNormalsFace = this.morphNormals[i1].faceNormals;
                const dstNormalsVertex = this.morphNormals[i1].vertexNormals;
                for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                    const faceNormal = new Vector3();
                    const vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            const morphNormals = this.morphNormals[i1];
            tmpGeo.vertices = this.morphTargets[i1].vertices;
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            for(let f2 = 0, fl2 = this.faces.length; f2 < fl2; f2++){
                const face1 = this.faces[f2];
                const faceNormal1 = morphNormals.faceNormals[f2];
                const vertexNormals1 = morphNormals.vertexNormals[f2];
                faceNormal1.copy(face1.normal);
                vertexNormals1.a.copy(face1.vertexNormals[0]);
                vertexNormals1.b.copy(face1.vertexNormals[1]);
                vertexNormals1.c.copy(face1.vertexNormals[2]);
            }
        }
        for(let f3 = 0, fl3 = this.faces.length; f3 < fl3; f3++){
            const face2 = this.faces[f3];
            face2.normal = face2.__originalFaceNormal;
            face2.vertexNormals = face2.__originalVertexNormals;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
            console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            return;
        }
        let normalMatrix;
        const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) {
            normalMatrix = new Matrix3().getNormalMatrix(matrix);
        }
        for(let i = 0, il = vertices2.length; i < il; i++){
            const vertex = vertices2[i];
            const vertexCopy = vertex.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        for(let i1 = 0, il1 = colors2.length; i1 < il1; i1++){
            colors1.push(colors2[i1].clone());
        }
        for(let i2 = 0, il2 = faces2.length; i2 < il2; i2++){
            const face = faces2[i2];
            let normal, color;
            const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) {
                faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            }
            for(let j = 0, jl = faceVertexNormals.length; j < jl; j++){
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) {
                    normal.applyMatrix3(normalMatrix).normalize();
                }
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for(let j1 = 0, jl1 = faceVertexColors.length; j1 < jl1; j1++){
                color = faceVertexColors[j1];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        for(let i3 = 0, il3 = geometry.faceVertexUvs.length; i3 < il3; i3++){
            const faceVertexUvs2 = geometry.faceVertexUvs[i3];
            if (this.faceVertexUvs[i3] === undefined) this.faceVertexUvs[i3] = [];
            for(let j2 = 0, jl2 = faceVertexUvs2.length; j2 < jl2; j2++){
                const uvs2 = faceVertexUvs2[j2], uvsCopy = [];
                for(let k = 0, kl = uvs2.length; k < kl; k++){
                    uvsCopy.push(uvs2[k].clone());
                }
                this.faceVertexUvs[i3].push(uvsCopy);
            }
        }
    },
    mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
            console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
            return;
        }
        if (mesh.matrixAutoUpdate) mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function() {
        const verticesMap = {};
        const unique = [], changes = [];
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        for(let i = 0, il = this.vertices.length; i < il; i++){
            const v = this.vertices[i];
            const key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;
            } else {
                changes[i] = changes[verticesMap[key]];
            }
        }
        const faceIndicesToRemove = [];
        for(let i1 = 0, il1 = this.faces.length; i1 < il1; i1++){
            const face = this.faces[i1];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            const indices = [
                face.a,
                face.b,
                face.c
            ];
            for(let n = 0; n < 3; n++){
                if (indices[n] === indices[(n + 1) % 3]) {
                    faceIndicesToRemove.push(i1);
                    break;
                }
            }
        }
        for(let i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--){
            const idx = faceIndicesToRemove[i2];
            this.faces.splice(idx, 1);
            for(let j = 0, jl = this.faceVertexUvs.length; j < jl; j++){
                this.faceVertexUvs[j].splice(idx, 1);
            }
        }
        const diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    setFromPoints: function(points) {
        this.vertices = [];
        for(let i = 0, l = points.length; i < l; i++){
            const point = points[i];
            this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return this;
    },
    sortFacesByMaterialIndex: function() {
        const faces = this.faces;
        const length = faces.length;
        for(let i = 0; i < length; i++){
            faces[i]._id = i;
        }
        function materialIndexSort(a, b) {
            return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        const uvs1 = this.faceVertexUvs[0];
        const uvs2 = this.faceVertexUvs[1];
        let newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length) newUvs1 = [];
        if (uvs2 && uvs2.length === length) newUvs2 = [];
        for(let i1 = 0; i1 < length; i1++){
            const id = faces[i1]._id;
            if (newUvs1) newUvs1.push(uvs1[id]);
            if (newUvs2) newUvs2.push(uvs2[id]);
        }
        if (newUvs1) this.faceVertexUvs[0] = newUvs1;
        if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters){
                if (parameters[key] !== undefined) data[key] = parameters[key];
            }
            return data;
        }
        const vertices = [];
        for(let i = 0; i < this.vertices.length; i++){
            const vertex = this.vertices[i];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        const faces = [];
        const normals = [];
        const normalsHash = {};
        const colors = [];
        const colorsHash = {};
        const uvs = [];
        const uvsHash = {};
        for(let i1 = 0; i1 < this.faces.length; i1++){
            const face = this.faces[i1];
            const hasMaterial = true;
            const hasFaceUv = false;
            const hasFaceVertexUv = this.faceVertexUvs[0][i1] !== undefined;
            const hasFaceNormal = face.normal.length() > 0;
            const hasFaceVertexNormal = face.vertexNormals.length > 0;
            const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            const hasFaceVertexColor = face.vertexColors.length > 0;
            let faceType = 0;
            faceType = setBit(faceType, 0, 0);
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                const faceVertexUvs = this.faceVertexUvs[0][i1];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) {
                faces.push(getNormalIndex(face.normal));
            }
            if (hasFaceVertexNormal) {
                const vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) {
                faces.push(getColorIndex(face.color));
            }
            if (hasFaceVertexColor) {
                const vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
            const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) {
                return normalsHash[hash];
            }
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            const hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) {
                return colorsHash[hash];
            }
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            const hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) {
                return uvsHash[hash];
            }
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0) data.data.colors = colors;
        if (uvs.length > 0) data.data.uvs = [
            uvs
        ];
        data.data.faces = faces;
        return data;
    },
    clone: function() {
        return new Geometry().copy(this);
    },
    copy: function(source) {
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.name = source.name;
        const vertices = source.vertices;
        for(let i = 0, il = vertices.length; i < il; i++){
            this.vertices.push(vertices[i].clone());
        }
        const colors = source.colors;
        for(let i1 = 0, il1 = colors.length; i1 < il1; i1++){
            this.colors.push(colors[i1].clone());
        }
        const faces = source.faces;
        for(let i2 = 0, il2 = faces.length; i2 < il2; i2++){
            this.faces.push(faces[i2].clone());
        }
        for(let i3 = 0, il3 = source.faceVertexUvs.length; i3 < il3; i3++){
            const faceVertexUvs = source.faceVertexUvs[i3];
            if (this.faceVertexUvs[i3] === undefined) {
                this.faceVertexUvs[i3] = [];
            }
            for(let j = 0, jl = faceVertexUvs.length; j < jl; j++){
                const uvs = faceVertexUvs[j], uvsCopy = [];
                for(let k = 0, kl = uvs.length; k < kl; k++){
                    const uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i3].push(uvsCopy);
            }
        }
        const morphTargets = source.morphTargets;
        for(let i4 = 0, il4 = morphTargets.length; i4 < il4; i4++){
            const morphTarget = {};
            morphTarget.name = morphTargets[i4].name;
            if (morphTargets[i4].vertices !== undefined) {
                morphTarget.vertices = [];
                for(let j1 = 0, jl1 = morphTargets[i4].vertices.length; j1 < jl1; j1++){
                    morphTarget.vertices.push(morphTargets[i4].vertices[j1].clone());
                }
            }
            if (morphTargets[i4].normals !== undefined) {
                morphTarget.normals = [];
                for(let j2 = 0, jl2 = morphTargets[i4].normals.length; j2 < jl2; j2++){
                    morphTarget.normals.push(morphTargets[i4].normals[j2].clone());
                }
            }
            this.morphTargets.push(morphTarget);
        }
        const morphNormals = source.morphNormals;
        for(let i5 = 0, il5 = morphNormals.length; i5 < il5; i5++){
            const morphNormal = {};
            if (morphNormals[i5].vertexNormals !== undefined) {
                morphNormal.vertexNormals = [];
                for(let j3 = 0, jl3 = morphNormals[i5].vertexNormals.length; j3 < jl3; j3++){
                    const srcVertexNormal = morphNormals[i5].vertexNormals[j3];
                    const destVertexNormal = {};
                    destVertexNormal.a = srcVertexNormal.a.clone();
                    destVertexNormal.b = srcVertexNormal.b.clone();
                    destVertexNormal.c = srcVertexNormal.c.clone();
                    morphNormal.vertexNormals.push(destVertexNormal);
                }
            }
            if (morphNormals[i5].faceNormals !== undefined) {
                morphNormal.faceNormals = [];
                for(let j4 = 0, jl4 = morphNormals[i5].faceNormals.length; j4 < jl4; j4++){
                    morphNormal.faceNormals.push(morphNormals[i5].faceNormals[j4].clone());
                }
            }
            this.morphNormals.push(morphNormal);
        }
        const skinWeights = source.skinWeights;
        for(let i6 = 0, il6 = skinWeights.length; i6 < il6; i6++){
            this.skinWeights.push(skinWeights[i6].clone());
        }
        const skinIndices = source.skinIndices;
        for(let i7 = 0, il7 = skinIndices.length; i7 < il7; i7++){
            this.skinIndices.push(skinIndices[i7].clone());
        }
        const lineDistances = source.lineDistances;
        for(let i8 = 0, il8 = lineDistances.length; i8 < il8; i8++){
            this.lineDistances.push(lineDistances[i8]);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
        }
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
class CylinderBufferGeometry extends BufferGeometry {
    constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength){
        super();
        this.type = "CylinderBufferGeometry";
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        const scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height = height || 1;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let index = 0;
        const indexArray = [];
        const halfHeight = height / 2;
        let groupStart = 0;
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
            const normal = new Vector3();
            const vertex = new Vector3();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height;
            for(let y = 0; y <= heightSegments; y++){
                const indexRow = [];
                const v = y / heightSegments;
                const radius = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x = 0; x <= radialSegments; x++){
                    const u = x / radialSegments;
                    const theta = u * thetaLength + thetaStart;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    uvs.push(u, 1 - v);
                    indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for(let x1 = 0; x1 < radialSegments; x1++){
                for(let y1 = 0; y1 < heightSegments; y1++){
                    const a = indexArray[y1][x1];
                    const b = indexArray[y1 + 1][x1];
                    const c = indexArray[y1 + 1][x1 + 1];
                    const d = indexArray[y1][x1 + 1];
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
        }
        function generateCap(top) {
            const centerIndexStart = index;
            const uv = new Vector2();
            const vertex = new Vector3();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign = top === true ? 1 : -1;
            for(let x = 1; x <= radialSegments; x++){
                vertices.push(0, halfHeight * sign, 0);
                normals.push(0, sign, 0);
                uvs.push(0.5, 0.5);
                index++;
            }
            const centerIndexEnd = index;
            for(let x1 = 0; x1 <= radialSegments; x1++){
                const u = x1 / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, sign, 0);
                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign + 0.5;
                uvs.push(uv.x, uv.y);
                index++;
            }
            for(let x2 = 0; x2 < radialSegments; x2++){
                const c = centerIndexStart + x2;
                const i = centerIndexEnd + x2;
                if (top === true) {
                    indices.push(i, i + 1, c);
                } else {
                    indices.push(i + 1, i, c);
                }
                groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
        }
    }
}
class CylinderGeometry extends Geometry {
    constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength){
        super();
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
}
new Vector3();
new Vector3();
new Vector3();
new Triangle();
const Earcut = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i = dim; i < outerLen; i += dim){
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        if (ear === stop) {
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false;
    let p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false;
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                let c = splitPolygon(a, b);
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for(i = 0; i < queue.length; i++){
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p1, p2, q1)) return true;
    if (o2 === 0 && onSegment(p1, q2, q1)) return true;
    if (o3 === 0 && onSegment(p2, p1, q2)) return true;
    if (o4 === 0 && onSegment(p2, q1, q2)) return true;
    return false;
}
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
    let p = a, inside = false;
    const px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
const ShapeUtils = {
    area: function(contour) {
        const n = contour.length;
        let a = 0.0;
        for(let p = n - 1, q = 0; q < n; p = q++){
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        const vertices = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i = 0; i < holes.length; i++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
        }
        const triangles = Earcut.triangulate(vertices, holeIndices);
        for(let i1 = 0; i1 < triangles.length; i1 += 3){
            faces.push(triangles.slice(i1, i1 + 3));
        }
        return faces;
    }
};
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
    }
}
function addContour(vertices, contour) {
    for(let i = 0; i < contour.length; i++){
        vertices.push(contour[i].x);
        vertices.push(contour[i].y);
    }
}
class ExtrudeBufferGeometry extends BufferGeometry {
    constructor(shapes, options){
        super();
        this.type = "ExtrudeBufferGeometry";
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [
            shapes
        ];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for(let i = 0, l = shapes.length; i < l; i++){
            const shape = shapes[i];
            addShape(shape);
        }
        this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        function addShape(shape) {
            const placeholder = [];
            const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            const steps = options.steps !== undefined ? options.steps : 1;
            let depth = options.depth !== undefined ? options.depth : 100;
            let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
            if (options.amount !== undefined) {
                console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
                depth = options.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false;
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
            }
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
                const ahole1 = holes[h1];
                vertices = vertices.concat(ahole1);
            }
            function scalePt2(pt, vec, size) {
                if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
                return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
                let v_trans_x, v_trans_y, shrink_by;
                const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                    const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                    const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                    const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2) {
                        return new Vector2(v_trans_x, v_trans_y);
                    } else {
                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                    }
                } else {
                    let direction_eq = false;
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        } else {
                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for(let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++){
                if (j === il) j = 0;
                if (k === il) k = 0;
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                const ahole2 = holes[h2];
                oneHoleMovements = [];
                for(let i1 = 0, il1 = ahole2.length, j1 = il1 - 1, k1 = i1 + 1; i1 < il1; i1++, j1++, k1++){
                    if (j1 === il1) j1 = 0;
                    if (k1 === il1) k1 = 0;
                    oneHoleMovements[i1] = getBevelVec(ahole2[i1], ahole2[j1], ahole2[k1]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for(let b = 0; b < bevelSegments; b++){
                const t = b / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                for(let i2 = 0, il2 = contour.length; i2 < il2; i2++){
                    const vert = scalePt2(contour[i2], contourMovements[i2], bs);
                    v(vert.x, vert.y, -z);
                }
                for(let h3 = 0, hl3 = holes.length; h3 < hl3; h3++){
                    const ahole3 = holes[h3];
                    oneHoleMovements = holesMovements[h3];
                    for(let i3 = 0, il3 = ahole3.length; i3 < il3; i3++){
                        const vert1 = scalePt2(ahole3[i3], oneHoleMovements[i3], bs);
                        v(vert1.x, vert1.y, -z);
                    }
                }
            }
            const bs1 = bevelSize + bevelOffset;
            for(let i4 = 0; i4 < vlen; i4++){
                const vert2 = bevelEnabled ? scalePt2(vertices[i4], verticesMovements[i4], bs1) : vertices[i4];
                if (!extrudeByPath) {
                    v(vert2.x, vert2.y, 0);
                } else {
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert2.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert2.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            for(let s = 1; s <= steps; s++){
                for(let i5 = 0; i5 < vlen; i5++){
                    const vert3 = bevelEnabled ? scalePt2(vertices[i5], verticesMovements[i5], bs1) : vertices[i5];
                    if (!extrudeByPath) {
                        v(vert3.x, vert3.y, depth / steps * s);
                    } else {
                        normal.copy(splineTube.normals[s]).multiplyScalar(vert3.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert3.y);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
            }
            for(let b1 = bevelSegments - 1; b1 >= 0; b1--){
                const t1 = b1 / bevelSegments;
                const z1 = bevelThickness * Math.cos(t1 * Math.PI / 2);
                const bs2 = bevelSize * Math.sin(t1 * Math.PI / 2) + bevelOffset;
                for(let i6 = 0, il4 = contour.length; i6 < il4; i6++){
                    const vert4 = scalePt2(contour[i6], contourMovements[i6], bs2);
                    v(vert4.x, vert4.y, depth + z1);
                }
                for(let h4 = 0, hl4 = holes.length; h4 < hl4; h4++){
                    const ahole4 = holes[h4];
                    oneHoleMovements = holesMovements[h4];
                    for(let i7 = 0, il5 = ahole4.length; i7 < il5; i7++){
                        const vert5 = scalePt2(ahole4[i7], oneHoleMovements[i7], bs2);
                        if (!extrudeByPath) {
                            v(vert5.x, vert5.y, depth + z1);
                        } else {
                            v(vert5.x, vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z1);
                        }
                    }
                }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
                const start = verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0;
                    let offset = vlen * layer;
                    for(let i = 0; i < flen; i++){
                        const face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    for(let i1 = 0; i1 < flen; i1++){
                        const face1 = faces[i1];
                        f3(face1[0] + offset, face1[1] + offset, face1[2] + offset);
                    }
                } else {
                    for(let i2 = 0; i2 < flen; i2++){
                        const face2 = faces[i2];
                        f3(face2[2], face2[1], face2[0]);
                    }
                    for(let i3 = 0; i3 < flen; i3++){
                        const face3 = faces[i3];
                        f3(face3[0] + vlen * steps, face3[1] + vlen * steps, face3[2] + vlen * steps);
                    }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
                const start = verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    layeroffset += ahole.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour, layeroffset) {
                let i = contour.length;
                while(--i >= 0){
                    const j = i;
                    let k = i - 1;
                    if (k < 0) k = contour.length - 1;
                    for(let s = 0, sl = steps + bevelSegments * 2; s < sl; s++){
                        const slen1 = vlen * s;
                        const slen2 = vlen * (s + 1);
                        const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    toJSON() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON(shapes, options, data);
    }
}
const WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y), 
        ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) {
            return [
                new Vector2(a_x, 1 - a_z),
                new Vector2(b_x, 1 - b_z),
                new Vector2(c_x, 1 - c_z),
                new Vector2(d_x, 1 - d_z), 
            ];
        } else {
            return [
                new Vector2(a_y, 1 - a_z),
                new Vector2(b_y, 1 - b_z),
                new Vector2(c_y, 1 - c_z),
                new Vector2(d_y, 1 - d_z), 
            ];
        }
    }
};
function toJSON(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
        for(let i = 0, l = shapes.length; i < l; i++){
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
        }
    } else {
        data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== undefined) {
        data.options.extrudePath = options.extrudePath.toJSON();
    }
    return data;
}
class ExtrudeGeometry extends Geometry {
    constructor(shapes, options){
        super();
        this.type = "ExtrudeGeometry";
        this.parameters = {
            shapes: shapes,
            options: options
        };
        this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
        this.mergeVertices();
    }
    toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON1(shapes, options, data);
    }
}
function toJSON1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
        for(let i = 0, l = shapes.length; i < l; i++){
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
        }
    } else {
        data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== undefined) {
        data.options.extrudePath = options.extrudePath.toJSON();
    }
    return data;
}
function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func.length < 3) {
        console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    }
    const sliceCount = slices + 1;
    for(let i = 0; i <= stacks; i++){
        const v = i / stacks;
        for(let j = 0; j <= slices; j++){
            const u = j / slices;
            func(u, v, p0);
            vertices.push(p0.x, p0.y, p0.z);
            if (u - 0.00001 >= 0) {
                func(u - 0.00001, v, p1);
                pu.subVectors(p0, p1);
            } else {
                func(u + 0.00001, v, p1);
                pu.subVectors(p1, p0);
            }
            if (v - 0.00001 >= 0) {
                func(u, v - 0.00001, p1);
                pv.subVectors(p0, p1);
            } else {
                func(u, v + 0.00001, p1);
                pv.subVectors(p1, p0);
            }
            normal.crossVectors(pu, pv).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(u, v);
        }
    }
    for(let i1 = 0; i1 < stacks; i1++){
        for(let j1 = 0; j1 < slices; j1++){
            const a = i1 * sliceCount + j1;
            const b = i1 * sliceCount + j1 + 1;
            const c = (i1 + 1) * sliceCount + j1 + 1;
            const d = (i1 + 1) * sliceCount + j1;
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
class ShapeBufferGeometry extends BufferGeometry {
    constructor(shapes, curveSegments){
        super();
        this.type = "ShapeBufferGeometry";
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        curveSegments = curveSegments || 12;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let groupStart = 0;
        let groupCount = 0;
        if (Array.isArray(shapes) === false) {
            addShape(shapes);
        } else {
            for(let i = 0; i < shapes.length; i++){
                addShape(shapes[i]);
                this.addGroup(groupStart, groupCount, i);
                groupStart += groupCount;
                groupCount = 0;
            }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
            }
            for(let i = 0, l = shapeHoles.length; i < l; i++){
                const shapeHole = shapeHoles[i];
                if (ShapeUtils.isClockWise(shapeHole) === true) {
                    shapeHoles[i] = shapeHole.reverse();
                }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for(let i1 = 0, l1 = shapeHoles.length; i1 < l1; i1++){
                const shapeHole1 = shapeHoles[i1];
                shapeVertices = shapeVertices.concat(shapeHole1);
            }
            for(let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++){
                const vertex = shapeVertices[i2];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y);
            }
            for(let i3 = 0, l3 = faces.length; i3 < l3; i3++){
                const face = faces[i3];
                const a = face[0] + indexOffset;
                const b = face[1] + indexOffset;
                const c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    toJSON() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        const shapes = this.parameters.shapes;
        return toJSON2(shapes, data);
    }
}
function toJSON2(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
        for(let i = 0, l = shapes.length; i < l; i++){
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
        }
    } else {
        data.shapes.push(shapes.uuid);
    }
    return data;
}
class ShapeGeometry extends Geometry {
    constructor(shapes, curveSegments){
        super();
        this.type = "ShapeGeometry";
        if (typeof curveSegments === "object") {
            console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
            curveSegments = curveSegments.curveSegments;
        }
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }
    toJSON() {
        const data = Geometry.prototype.toJSON.call(this);
        const shapes = this.parameters.shapes;
        return toJSON3(shapes, data);
    }
}
function toJSON3(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
        for(let i = 0, l = shapes.length; i < l; i++){
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
        }
    } else {
        data.shapes.push(shapes.uuid);
    }
    return data;
}
class TextBufferGeometry extends ExtrudeBufferGeometry {
    constructor(text1, parameters){
        parameters = parameters || {};
        const font = parameters.font;
        if (!(font && font.isFont)) {
            console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
            return new BufferGeometry();
        }
        const shapes = font.generateShapes(text1, parameters.size);
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
        super(shapes, parameters);
        this.type = "TextBufferGeometry";
    }
}
class TextGeometry extends Geometry {
    constructor(text1, parameters){
        super();
        this.type = "TextGeometry";
        this.parameters = {
            text: text1,
            parameters: parameters
        };
        this.fromBufferGeometry(new TextBufferGeometry(text1, parameters));
        this.mergeVertices();
    }
}
function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = "ShadowMaterial";
    this.color = new Color(0x000000);
    this.transparent = true;
    this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
};
function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {
        "STANDARD": ""
    };
    this.type = "MeshStandardMaterial";
    this.color = new Color(0xffffff);
    this.roughness = 1.0;
    this.metalness = 0.0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1.0;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        "STANDARD": ""
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
};
function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoat = 0.0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0.0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5;
    Object.defineProperty(this, "ior", {
        get: function() {
            return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
        },
        set: function(ior) {
            this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
        }
    });
    this.sheen = null;
    this.transmission = 0.0;
    this.transmissionMap = null;
    this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) {
        this.sheen = (this.sheen || new Color()).copy(source.sheen);
    } else {
        this.sheen = null;
    }
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    return this;
};
function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new Color(0xffffff);
    this.specular = new Color(0x111111);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function MeshToonMaterial(parameters) {
    Material.call(this);
    this.defines = {
        "TOON": ""
    };
    this.type = "MeshToonMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = {
        "MATCAP": ""
    };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(0xffffff);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        "MATCAP": ""
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
const mod = {
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
};
const AnimationUtils = {
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        }
        return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) {
            return array;
        }
        if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
        }
        return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
        function compareTime(i, j) {
            return times[i] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i = 0; i !== n; ++i)result[i] = i;
        result.sort(compareTime);
        return result;
    },
    sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i = 0, dstOffset = 0; dstOffset !== nValues; ++i){
            const srcOffset = order[i] * stride;
            for(let j = 0; j !== stride; ++j){
                result[dstOffset++] = values[srcOffset + j];
            }
        }
        return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined){
            key = jsonKeys[i++];
        }
        if (key === undefined) return;
        let value = key[valuePropertyName];
        if (value === undefined) return;
        if (Array.isArray(value)) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push.apply(values, value);
                }
                key = jsonKeys[i++];
            }while (key !== undefined)
        } else if (value.toArray !== undefined) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    value.toArray(values, values.length);
                }
                key = jsonKeys[i++];
            }while (key !== undefined)
        } else {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push(value);
                }
                key = jsonKeys[i++];
            }while (key !== undefined)
        }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i = 0; i < clip.tracks.length; ++i){
            const track = clip.tracks[i];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j = 0; j < track.times.length; ++j){
                const frame = track.times[j] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j]);
                for(let k = 0; k < valueSize; ++k){
                    values.push(track.values[j * valueSize + k]);
                }
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for(let i1 = 0; i1 < clip.tracks.length; ++i1){
            if (minStartTime > clip.tracks[i1].times[0]) {
                minStartTime = clip.tracks[i1].times[0];
            }
        }
        for(let i2 = 0; i2 < clip.tracks.length; ++i2){
            clip.tracks[i2].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === undefined) referenceFrame = 0;
        if (referenceClip === undefined) referenceClip = targetClip;
        if (fps === undefined || fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for(let i = 0; i < numTracks; ++i){
            const referenceTrack = referenceClip.tracks[i];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string") {
                continue;
            }
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                const startIndex1 = lastIndex * referenceValueSize + referenceOffset;
                const endIndex1 = startIndex1 + referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex1, endIndex1);
            } else {
                const interpolant = referenceTrack.createInterpolant();
                const startIndex2 = referenceOffset;
                const endIndex2 = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex2, endIndex2);
            }
            if (referenceTrackType === "quaternion") {
                const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for(let j = 0; j < numTimes; ++j){
                const valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === "quaternion") {
                    Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                } else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    for(let k = 0; k < valueEnd; ++k){
                        targetTrack.values[valueStart + k] -= referenceValue[k];
                    }
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    forward_scan: if (!(t < t1)) {
                        for(let giveUpAt = i1 + 2;;){
                            if (t1 === undefined) {
                                if (t < t0) break forward_scan;
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t, t0);
                            }
                            if (i1 === giveUpAt) break;
                            t0 = t1;
                            t1 = pp[++i1];
                            if (t < t1) {
                                break seek;
                            }
                        }
                        right = pp.length;
                        break linear_scan;
                    }
                    if (!(t >= t0)) {
                        const t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2;
                            t0 = t1global;
                        }
                        for(let giveUpAt1 = i1 - 2;;){
                            if (t0 === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt1) break;
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) {
                                break seek;
                            }
                        }
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                }
                while(i1 < right){
                    const mid = i1 + right >>> 1;
                    if (t < pp[mid]) {
                        right = mid;
                    } else {
                        i1 = mid + 1;
                    }
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for(let i = 0; i !== stride; ++i){
            result[i] = values[offset + i];
        }
        return result;
    },
    interpolate_: function() {
        throw new Error("call to abstract method");
    },
    intervalChanged_: function() {}
});
Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) {
            switch(this.getSettings_().endingStart){
                case ZeroSlopeEnding:
                    iPrev = i1;
                    tPrev = 2 * t0 - t1;
                    break;
                case WrapAroundEnding:
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                default:
                    iPrev = i1;
                    tPrev = t1;
            }
        }
        if (tNext === undefined) {
            switch(this.getSettings_().endingEnd){
                case ZeroSlopeEnding:
                    iNext = i1;
                    tNext = 2 * t1 - t0;
                    break;
                case WrapAroundEnding:
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;
                default:
                    iNext = i1 - 1;
                    tNext = t0;
            }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        for(let i = 0; i !== stride; ++i){
            result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
        }
        return result;
    }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(let i = 0; i !== stride; ++i){
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
    }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1) {
        return this.copySampleValue_(i1 - 1);
    }
});
function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) {
        throw new Error("THREE.KeyframeTrack: track name is undefined");
    }
    if (times === undefined || times.length === 0) {
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    }
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
Object.assign(KeyframeTrack, {
    toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== undefined) {
            json = trackType.toJSON(track);
        } else {
            json = {
                "name": track.name,
                "times": AnimationUtils.convertArray(track.times, Array),
                "values": AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
                json.interpolation = interpolation;
            }
        }
        json.type = track.ValueTypeName;
        return json;
    }
});
Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case 2300:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                if (interpolation !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                } else {
                    throw new Error(message);
                }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    shift: function(timeOffset) {
        if (timeOffset !== 0.0) {
            const times = this.times;
            for(let i = 0, n = times.length; i !== n; ++i){
                times[i] += timeOffset;
            }
        }
        return this;
    },
    scale: function(timeScale) {
        if (timeScale !== 1.0) {
            const times = this.times;
            for(let i = 0, n = times.length; i !== n; ++i){
                times[i] *= timeScale;
            }
        }
        return this;
    },
    trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime){
            ++from;
        }
        while(to !== -1 && times[to] > endTime){
            --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
        }
        let prevTime = null;
        for(let i = 0; i !== nKeys; i++){
            const currTime = times[i];
            if (typeof currTime === "number" && isNaN(currTime)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) {
                for(let i1 = 0, n = values.length; i1 !== n; ++i1){
                    const value = values[i1];
                    if (isNaN(value)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i1, value);
                        valid = false;
                        break;
                    }
                }
            }
        }
        return valid;
    },
    optimize: function() {
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === 2302, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i = 1; i < lastIndex; ++i){
            let keep = false;
            const time = times[i];
            const timeNext = times[i + 1];
            if (time !== timeNext && (i !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j = 0; j !== stride; ++j){
                        const value = values[offset + j];
                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                } else {
                    keep = true;
                }
            }
            if (keep) {
                if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    const readOffset = i * stride, writeOffset = writeIndex * stride;
                    for(let j1 = 0; j1 !== stride; ++j1){
                        values[writeOffset + j1] = values[readOffset + j1];
                    }
                }
                ++writeIndex;
            }
        }
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset1 = lastIndex * stride, writeOffset1 = writeIndex * stride, j2 = 0; j2 !== stride; ++j2){
                values[writeOffset1 + j2] = values[readOffset1 + j2];
            }
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    },
    clone: function() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
    }
});
function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: "color"
});
function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: "number"
});
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset = i1 * stride;
        for(let end = offset + stride; offset !== end; offset += 4){
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
    }
});
function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: "vector"
});
function AnimationClip(name, duration, tracks, blendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
        this.resetDuration();
    }
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return VectorKeyframeTrack;
        case "color":
            return ColorKeyframeTrack;
        case "quaternion":
            return QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
            return BooleanKeyframeTrack;
        case "string":
            return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) {
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
    }
    if (trackType.parse !== undefined) {
        return trackType.parse(json);
    } else {
        return new trackType(json.name, json.times, json.values, json.interpolation);
    }
}
Object.assign(AnimationClip, {
    parse: function(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
        for(let i = 0, n = jsonTracks.length; i !== n; ++i){
            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
        }
        return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
    },
    toJSON: function(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
        };
        for(let i = 0, n = clipTracks.length; i !== n; ++i){
            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
        }
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i = 0; i < numMorphTargets; i++){
            let times = [];
            let values = [];
            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1.0 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i = 0; i < clipArray.length; i++){
            if (clipArray[i].name === name) {
                return clipArray[i];
            }
        }
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        const pattern = /^([\w-]*?)([\d]+)$/;
        for(let i = 0, il = morphTargets.length; i < il; i++){
            const morphTarget = morphTargets[i];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) {
                    animationToMorphTargets[name] = animationMorphTargets = [];
                }
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name1 in animationToMorphTargets){
            clips.push(AnimationClip.CreateFromMorphTargetSequence(name1, animationToMorphTargets[name1], fps, noLoop));
        }
        return clips;
    },
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                if (times.length !== 0) {
                    destTracks.push(new trackType(trackName, times, values));
                }
            }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0) continue;
            if (animationKeys[0].morphTargets) {
                const morphTargetNames = {};
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) {
                        for(let m = 0; m < animationKeys[k].morphTargets.length; m++){
                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                        }
                    }
                }
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m1 = 0; m1 !== animationKeys[k].morphTargets.length; ++m1){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                }
                duration = morphTargetNames.length * (fps || 1.0);
            } else {
                const boneName = ".bones[" + bones[h].name + "]";
                addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
        }
        if (tracks.length === 0) {
            return null;
        }
        const clip = new AnimationClip(clipName, duration, tracks, blendMode);
        return clip;
    }
});
Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i = 0, n = tracks.length; i !== n; ++i){
            const track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(let i = 0; i < this.tracks.length; i++){
            this.tracks[i].trim(0, this.duration);
        }
        return this;
    },
    validate: function() {
        let valid = true;
        for(let i = 0; i < this.tracks.length; i++){
            valid = valid && this.tracks[i].validate();
        }
        return valid;
    },
    optimize: function() {
        for(let i = 0; i < this.tracks.length; i++){
            this.tracks[i].optimize();
        }
        return this;
    },
    clone: function() {
        const tracks = [];
        for(let i = 0; i < this.tracks.length; i++){
            tracks.push(this.tracks[i].clone());
        }
        return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
    }
});
const Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
        if (this.enabled === false) return;
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};
function LoadingManager(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope.onStart !== undefined) {
                scope.onStart(url, itemsLoaded, itemsTotal);
            }
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== undefined) {
                scope.onLoad();
            }
        }
    };
    this.itemError = function(url) {
        if (scope.onError !== undefined) {
            scope.onError(url);
        }
    };
    this.resolveURL = function(url) {
        if (urlModifier) {
            return urlModifier(url);
        }
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
    this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
    };
    this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) {
            handlers.splice(index, 2);
        }
        return this;
    };
    this.getHandler = function(file) {
        for(let i = 0, l = handlers.length; i < l; i += 2){
            const regex = handlers[i];
            const loader = handlers[i + 1];
            if (regex.global) regex.lastIndex = 0;
            if (regex.test(file)) {
                return loader;
            }
        }
        return null;
    };
}
const DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
}
Object.assign(Loader.prototype, {
    load: function() {},
    loadAsync: function(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
        });
    },
    parse: function() {},
    setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setPath: function(path) {
        this.path = path;
        return this;
    },
    setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    },
    setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
});
const loading = {};
function FileLoader(manager) {
    Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || "").toLowerCase();
                switch(responseType){
                    case "arraybuffer":
                    case "blob":
                        const view = new Uint8Array(data.length);
                        for(let i = 0; i < data.length; i++){
                            view[i] = data.charCodeAt(i);
                        }
                        if (responseType === "blob") {
                            response = new Blob([
                                view.buffer
                            ], {
                                type: mimeType
                            });
                        } else {
                            response = view.buffer;
                        }
                        break;
                    case "document":
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case "json":
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                setTimeout(function() {
                    if (onError) onError(error);
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, 0);
            }
        } else {
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.addEventListener("load", function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    if (this.status === 0) {
                        console.warn("THREE.FileLoader: HTTP Status 0 received.");
                    }
                    Cache.add(url, response);
                    for(let i = 0, il = callbacks.length; i < il; i++){
                        const callback = callbacks[i];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope.manager.itemEnd(url);
                } else {
                    for(let i1 = 0, il1 = callbacks.length; i1 < il1; i1++){
                        const callback1 = callbacks[i1];
                        if (callback1.onError) callback1.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener("progress", function(event) {
                const callbacks = loading[url];
                for(let i = 0, il = callbacks.length; i < il; i++){
                    const callback = callbacks[i];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener("error", function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i = 0, il = callbacks.length; i < il; i++){
                    const callback = callbacks[i];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            request.addEventListener("abort", function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i = 0, il = callbacks.length; i < il; i++){
                    const callback = callbacks[i];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) {
                request.responseType = this.responseType;
            }
            if (this.withCredentials !== undefined) {
                request.withCredentials = this.withCredentials;
            }
            if (request.overrideMimeType) {
                request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : "text/plain");
            }
            for(const header in this.requestHeader){
                request.setRequestHeader(header, this.requestHeader[header]);
            }
            request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    }
});
function AnimationLoader(manager) {
    Loader.call(this, manager);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AnimationLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const animations = [];
        for(let i = 0; i < json.length; i++){
            const clip = AnimationClip.parse(json[i]);
            animations.push(clip);
        }
        return animations;
    }
});
function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        texture.image = images;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        let loaded = 0;
        function loadTexture(i) {
            loader.load(url[i], function(buffer) {
                const texDatas = scope.parse(buffer, true);
                images[i] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) {
            for(let i = 0, il = url.length; i < il; ++i){
                loadTexture(i);
            }
        } else {
            loader.load(url, function(buffer) {
                const texDatas = scope.parse(buffer, true);
                if (texDatas.isCubemap) {
                    const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for(let f = 0; f < faces; f++){
                        images[f] = {
                            mipmaps: []
                        };
                        for(let i = 0; i < texDatas.mipmapCount; i++){
                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                            images[f].format = texDatas.format;
                            images[f].width = texDatas.width;
                            images[f].height = texDatas.height;
                        }
                    }
                } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                }
                if (texDatas.mipmapCount === 1) {
                    texture.minFilter = LinearFilter;
                }
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture);
            }, onProgress, onError);
        }
        return texture;
    }
});
function ImageLoader(manager) {
    Loader.call(this, manager);
}
ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function onImageLoad() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            Cache.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            if (onError) onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
    }
});
function CubeTextureLoader(manager) {
    Loader.call(this, manager);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i) {
            loader.load(urls[i], function(image) {
                texture.images[i] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i = 0; i < urls.length; ++i){
            loadTexture(i);
        }
        return texture;
    }
});
function DataTextureLoader(manager) {
    Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) {
                texture.image = texData.image;
            } else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.format !== undefined) {
                texture.format = texData.format;
            }
            if (texData.type !== undefined) {
                texture.type = texData.type;
            }
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = LinearMipmapLinearFilter;
            }
            if (texData.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
            }
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
});
function TextureLoader(manager) {
    Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) {
                onLoad(texture);
            }
        }, onProgress, onError);
        return texture;
    }
});
function Curve() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
    getPoint: function() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
    },
    getPointAt: function(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
    },
    getPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        const points = [];
        for(let d = 0; d <= divisions; d++){
            points.push(this.getPoint(d / divisions));
        }
        return points;
    },
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        const points = [];
        for(let d = 0; d <= divisions; d++){
            points.push(this.getPointAt(d / divisions));
        }
        return points;
    },
    getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
        if (divisions === undefined) divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i = 0;
        const il = arcLengths.length;
        let targetArcLength;
        if (distance) {
            targetArcLength = distance;
        } else {
            targetArcLength = u * arcLengths[il - 1];
        }
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
                low = i + 1;
            } else if (comparison > 0) {
                high = i - 1;
            } else {
                high = i;
                break;
            }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
            return i / (il - 1);
        }
        const lengthBefore = arcLengths[i];
        const lengthAfter = arcLengths[i + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t = (i + segmentFraction) / (il - 1);
        return t;
    },
    getTangent: function(t, optionalTarget) {
        let t1 = t - 0.0001;
        let t2 = t + 0.0001;
        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
    },
    computeFrenetFrames: function(segments, closed) {
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        for(let i = 0; i <= segments; i++){
            const u = i / segments;
            tangents[i] = this.getTangentAt(u, new Vector3());
            tangents[i].normalize();
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) {
            normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for(let i1 = 1; i1 <= segments; i1++){
            normals[i1] = normals[i1 - 1].clone();
            binormals[i1] = binormals[i1 - 1].clone();
            vec.crossVectors(tangents[i1 - 1], tangents[i1]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos(MathUtils.clamp(tangents[i1 - 1].dot(tangents[i1]), -1, 1));
                normals[i1].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i1].crossVectors(tangents[i1], normals[i1]);
        }
        if (closed === true) {
            let theta1 = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
            theta1 /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                theta1 = -theta1;
            }
            for(let i2 = 1; i2 <= segments; i2++){
                normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta1 * i2));
                binormals[i2].crossVectors(tangents[i2], normals[i2]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = "EllipseCurve";
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
            deltaAngle = 0;
        } else {
            deltaAngle = twoPi;
        }
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
        } else {
            deltaAngle = deltaAngle - twoPi;
        }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x - this.aX;
        const ty = y - this.aY;
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
};
EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
        },
        calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
    };
}
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points, closed, curveType, tension) {
    Curve.call(this);
    this.type = "CatmullRomCurve3";
    this.points = points || [];
    this.closed = closed || false;
    this.curveType = curveType || "centripetal";
    this.tension = tension !== undefined ? tension : 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
    } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
    } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
        const pow = this.curveType === "chordal" ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 1e-4) dt1 = 1.0;
        if (dt0 < 1e-4) dt0 = dt1;
        if (dt2 < 1e-4) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i = 0, l = source.points.length; i < l; i++){
        const point = source.points[i];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i = 0, l = this.points.length; i < l; i++){
        const point = this.points[i];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i = 0, l = json.points.length; i < l; i++){
        const point = json.points[i];
        this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
}
function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
    return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
}
function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
    return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
    this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
    this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function LineCurve(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve";
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    if (t === 1) {
        point.copy(this.v2);
    } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
};
LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve3(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve3";
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    if (t === 1) {
        point.copy(this.v2);
    } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve(points) {
    Curve.call(this);
    this.type = "SplineCurve";
    this.points = points || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
};
SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i = 0, l = source.points.length; i < l; i++){
        const point = source.points[i];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i = 0, l = this.points.length; i < l; i++){
        const point = this.points[i];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i = 0, l = json.points.length; i < l; i++){
        const point = json.points[i];
        this.points.push(new Vector2().fromArray(point));
    }
    return this;
};
const mod1 = {
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
};
function CurvePath() {
    Curve.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
            this.curves.push(new mod1["LineCurve"](endPoint, startPoint));
        }
    },
    getPoint: function(t) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i = 0;
        while(i < curveLengths.length){
            if (curveLengths[i] >= d) {
                const diff = curveLengths[i] - d;
                const curve = this.curves[i];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i++;
        }
        return null;
    },
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
        }
        const lengths = [];
        let sums = 0;
        for(let i = 0, l = this.curves.length; i < l; i++){
            sums += this.curves[i].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 40;
        const points = [];
        for(let i = 0; i <= divisions; i++){
            points.push(this.getPoint(i / divisions));
        }
        if (this.autoClose) {
            points.push(points[0]);
        }
        return points;
    },
    getPoints: function(divisions) {
        divisions = divisions || 12;
        const points = [];
        let last;
        for(let i = 0, curves = this.curves; i < curves.length; i++){
            const curve = curves[i];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j = 0; j < pts.length; j++){
                const point = pts[j];
                if (last && last.equals(point)) continue;
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
        }
        return points;
    },
    copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for(let i = 0, l = source.curves.length; i < l; i++){
            const curve = source.curves[i];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i = 0, l = this.curves.length; i < l; i++){
            const curve = this.curves[i];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i = 0, l = json.curves.length; i < l; i++){
            const curve = json.curves[i];
            this.curves.push(new mod1[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
function Path(points) {
    CurvePath.call(this);
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
        this.setFromPoints(points);
    }
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points) {
        this.moveTo(points[0].x, points[0].y);
        for(let i = 1, l = points.length; i < l; i++){
            this.lineTo(points[i].x, points[i].y);
        }
        return this;
    },
    moveTo: function(x, y) {
        this.currentPoint.set(x, y);
        return this;
    },
    lineTo: function(x, y) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    splineThru: function(pts) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
                this.lineTo(firstPoint.x, firstPoint.y);
            }
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    },
    copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        const data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
function Shape(points) {
    Path.call(this, points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
        const holesPts = [];
        for(let i = 0, l = this.holes.length; i < l; i++){
            holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
    },
    extractPoints: function(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for(let i = 0, l = source.holes.length; i < l; i++){
            const hole = source.holes[i];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        const data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(let i = 0, l = this.holes.length; i < l; i++){
            const hole = this.holes[i];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i = 0, l = json.holes.length; i < l; i++){
            const hole = json.holes[i];
            this.holes.push(new Path().fromJSON(hole));
        }
        return this;
    }
});
function Light(color, intensity) {
    Object3D.call(this);
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) {
            data.object.groundColor = this.groundColor.getHex();
        }
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
        new Vector4(0, 0, 1, 1), 
    ];
}
Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix4(),
    _lightPositionWorld: new Vector3(),
    _lookTarget: new Vector3(),
    getViewportCount: function() {
        return this._viewportCount;
    },
    getFrustum: function() {
        return this._frustum;
    },
    updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
        return this._frameExtents;
    },
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const object = {};
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) {
            object.mapSize = this.mapSize.toArray();
        }
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
        const aspect = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
            camera.fov = fov;
            camera.aspect = aspect;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, "power", {
        get: function() {
            return this.intensity * Math.PI;
        },
        set: function(power) {
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
function PointLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1), 
    ];
    this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0), 
    ];
    this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1), 
    ];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function(light, viewportIndex) {
        if (viewportIndex === undefined) viewportIndex = 0;
        const camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
});
function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
        get: function() {
            return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new PointLightShadow();
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) {
            this.view = {
                enabled: true,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) {
            this.view.enabled = false;
        }
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
    }
});
function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "AmbientLight";
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
function RectAreaLight(color, intensity, width, height) {
    Light.call(this, color, intensity);
    this.type = "RectAreaLight";
    this.width = width !== undefined ? width : 10;
    this.height = height !== undefined ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
class SphericalHarmonics3 {
    constructor(){
        Object.defineProperty(this, "isSphericalHarmonics3", {
            value: true
        });
        this.coefficients = [];
        for(let i = 0; i < 9; i++){
            this.coefficients.push(new Vector3());
        }
    }
    set(coefficients) {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].copy(coefficients[i]);
        }
        return this;
    }
    zero() {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].set(0, 0, 0);
        }
        return this;
    }
    getAt(normal, target) {
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
    }
    getIrradianceAt(normal, target) {
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 2.0 * 0.511664 * y);
        target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);
        target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y);
        target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
        return target;
    }
    add(sh) {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].add(sh.coefficients[i]);
        }
        return this;
    }
    addScaledSH(sh, s) {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].addScaledVector(sh.coefficients[i], s);
        }
        return this;
    }
    scale(s) {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].multiplyScalar(s);
        }
        return this;
    }
    lerp(sh, alpha) {
        for(let i = 0; i < 9; i++){
            this.coefficients[i].lerp(sh.coefficients[i], alpha);
        }
        return this;
    }
    equals(sh) {
        for(let i = 0; i < 9; i++){
            if (!this.coefficients[i].equals(sh.coefficients[i])) {
                return false;
            }
        }
        return true;
    }
    copy(sh) {
        return this.set(sh.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for(let i = 0; i < 9; i++){
            coefficients[i].fromArray(array, offset + i * 3);
        }
        return this;
    }
    toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for(let i = 0; i < 9; i++){
            coefficients[i].toArray(array, offset + i * 3);
        }
        return array;
    }
    static getBasisAt(normal, shBasis) {
        const x = normal.x, y = normal.y, z = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
    }
}
function LightProbe(sh, intensity) {
    Light.call(this, undefined, intensity);
    this.type = "LightProbe";
    this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
    },
    fromJSON: function(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
});
function MaterialLoader(manager) {
    Loader.call(this, manager);
    this.textures = {};
}
MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) {
                console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
        }
        const material = new mod[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) {
            material.sheen = new Color().setHex(json.sheen);
        }
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) {
            material.clearcoatRoughness = json.clearcoatRoughness;
        }
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) {
            material.stencilWrite = json.stencilWrite;
        }
        if (json.stencilWriteMask !== undefined) {
            material.stencilWriteMask = json.stencilWriteMask;
        }
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) {
            material.stencilFuncMask = json.stencilFuncMask;
        }
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) {
            material.stencilZFail = json.stencilZFail;
        }
        if (json.stencilZPass !== undefined) {
            material.stencilZPass = json.stencilZPass;
        }
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) {
            material.wireframeLinewidth = json.wireframeLinewidth;
        }
        if (json.wireframeLinecap !== undefined) {
            material.wireframeLinecap = json.wireframeLinecap;
        }
        if (json.wireframeLinejoin !== undefined) {
            material.wireframeLinejoin = json.wireframeLinejoin;
        }
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) {
            material.polygonOffset = json.polygonOffset;
        }
        if (json.polygonOffsetFactor !== undefined) {
            material.polygonOffsetFactor = json.polygonOffsetFactor;
        }
        if (json.polygonOffsetUnits !== undefined) {
            material.polygonOffsetUnits = json.polygonOffsetUnits;
        }
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) {
            material.morphTargets = json.morphTargets;
        }
        if (json.morphNormals !== undefined) {
            material.morphNormals = json.morphNormals;
        }
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.vertexTangents !== undefined) {
            material.vertexTangents = json.vertexTangents;
        }
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === "number") {
                material.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
                material.vertexColors = json.vertexColors;
            }
        }
        if (json.uniforms !== undefined) {
            for(const name in json.uniforms){
                const uniform = json.uniforms[name];
                material.uniforms[name] = {};
                switch(uniform.type){
                    case "t":
                        material.uniforms[name].value = getTexture(uniform.value);
                        break;
                    case "c":
                        material.uniforms[name].value = new Color().setHex(uniform.value);
                        break;
                    case "v2":
                        material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                        break;
                    case "v3":
                        material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                        break;
                    case "v4":
                        material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                        break;
                    case "m3":
                        material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                        break;
                    case "m4":
                        material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                        break;
                    default:
                        material.uniforms[name].value = uniform.value;
                }
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) {
            material.vertexShader = json.vertexShader;
        }
        if (json.fragmentShader !== undefined) {
            material.fragmentShader = json.fragmentShader;
        }
        if (json.extensions !== undefined) {
            for(const key in json.extensions){
                material.extensions[key] = json.extensions[key];
            }
        }
        if (json.shading !== undefined) material.flatShading = json.shading === 1;
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) {
            material.sizeAttenuation = json.sizeAttenuation;
        }
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) {
            material.alphaMap = getTexture(json.alphaMap);
        }
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) {
            material.normalMap = getTexture(json.normalMap);
        }
        if (json.normalMapType !== undefined) {
            material.normalMapType = json.normalMapType;
        }
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
                normalScale = [
                    normalScale,
                    normalScale
                ];
            }
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) {
            material.displacementMap = getTexture(json.displacementMap);
        }
        if (json.displacementScale !== undefined) {
            material.displacementScale = json.displacementScale;
        }
        if (json.displacementBias !== undefined) {
            material.displacementBias = json.displacementBias;
        }
        if (json.roughnessMap !== undefined) {
            material.roughnessMap = getTexture(json.roughnessMap);
        }
        if (json.metalnessMap !== undefined) {
            material.metalnessMap = getTexture(json.metalnessMap);
        }
        if (json.emissiveMap !== undefined) {
            material.emissiveMap = getTexture(json.emissiveMap);
        }
        if (json.emissiveIntensity !== undefined) {
            material.emissiveIntensity = json.emissiveIntensity;
        }
        if (json.specularMap !== undefined) {
            material.specularMap = getTexture(json.specularMap);
        }
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) {
            material.envMapIntensity = json.envMapIntensity;
        }
        if (json.reflectivity !== undefined) {
            material.reflectivity = json.reflectivity;
        }
        if (json.refractionRatio !== undefined) {
            material.refractionRatio = json.refractionRatio;
        }
        if (json.lightMap !== undefined) {
            material.lightMap = getTexture(json.lightMap);
        }
        if (json.lightMapIntensity !== undefined) {
            material.lightMapIntensity = json.lightMapIntensity;
        }
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) {
            material.aoMapIntensity = json.aoMapIntensity;
        }
        if (json.gradientMap !== undefined) {
            material.gradientMap = getTexture(json.gradientMap);
        }
        if (json.clearcoatMap !== undefined) {
            material.clearcoatMap = getTexture(json.clearcoatMap);
        }
        if (json.clearcoatRoughnessMap !== undefined) {
            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        }
        if (json.clearcoatNormalMap !== undefined) {
            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        }
        if (json.clearcoatNormalScale !== undefined) {
            material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        }
        if (json.transmission !== undefined) {
            material.transmission = json.transmission;
        }
        if (json.transmissionMap !== undefined) {
            material.transmissionMap = getTexture(json.transmissionMap);
        }
        return material;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
const LoaderUtils = {
    decodeText: function(array) {
        if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
        }
        let s = "";
        for(let i = 0, il = array.length; i < il; i++){
            s += String.fromCharCode(array[i]);
        }
        try {
            return decodeURIComponent(escape(s));
        } catch (e) {
            return s;
        }
    },
    extractUrlBase: function(url) {
        const index = url.lastIndexOf("/");
        if (index === -1) return "./";
        return url.substr(0, index + 1);
    }
};
function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
function BufferGeometryLoader(manager) {
    Loader.call(this, manager);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) {
                return interleavedBufferMap[uuid];
            }
            const interleavedBuffers = json.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
            const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json, uuid) {
            if (arrayBufferMap[uuid] !== undefined) {
                return arrayBufferMap[uuid];
            }
            const arrayBuffers = json.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json.data.index;
        if (index !== undefined) {
            const typedArray = new TYPED_ARRAYS[index.type](index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray1 = new TYPED_ARRAYS[attribute.type](attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                bufferAttribute = new bufferAttributeConstr(typedArray1, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
            for(const key1 in morphAttributes){
                const attributeArray = morphAttributes[key1];
                const array = [];
                for(let i = 0, il = attributeArray.length; i < il; i++){
                    const attribute1 = attributeArray[i];
                    let bufferAttribute1;
                    if (attribute1.isInterleavedBufferAttribute) {
                        const interleavedBuffer1 = getInterleavedBuffer(json.data, attribute1.data);
                        bufferAttribute1 = new InterleavedBufferAttribute(interleavedBuffer1, attribute1.itemSize, attribute1.offset, attribute1.normalized);
                    } else {
                        const typedArray2 = new TYPED_ARRAYS[attribute1.type](attribute1.array);
                        bufferAttribute1 = new BufferAttribute(typedArray2, attribute1.itemSize, attribute1.normalized);
                    }
                    if (attribute1.name !== undefined) {
                        bufferAttribute1.name = attribute1.name;
                    }
                    array.push(bufferAttribute1);
                }
                geometry.morphAttributes[key1] = array;
            }
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
            geometry.morphTargetsRelative = true;
        }
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
            for(let i1 = 0, n = groups.length; i1 !== n; ++i1){
                const group = groups[i1];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center = new Vector3();
            if (boundingSphere.center !== undefined) {
                center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
    }
});
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    Loader.call(this, manager);
    this.options = {
        premultiplyAlpha: "none"
    };
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options) {
        this.options = options;
        return this;
    },
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetch(url, fetchOptions).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, scope.options);
        }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
    }
});
function ShapePath() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
    moveTo: function(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
    },
    lineTo: function(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for(let i = 0, l = inSubpaths.length; i < l; i++){
                const tmpPath = inSubpaths[i];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for(let p = polyLen - 1, q = 0; q < polyLen; p = q++){
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true;
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true;
                        if (perpEdge < 0) continue;
                        inside = !inside;
                    }
                } else {
                    if (inPt.y !== edgeLowPt.y) continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) {
                        return true;
                    }
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i = 0, l = subPaths.length; i < l; i++){
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            } else {
                newShapeHoles[mainIdx].push({
                    h: tmpPath,
                    p: tmpPoints[0]
                });
            }
        }
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++){
                betterShapeHoles[sIdx] = [];
            }
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++){
                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (sIdx1 !== s2Idx) {
                                toChange.push({
                                    froms: sIdx1,
                                    tos: s2Idx,
                                    hole: hIdx
                                });
                            }
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            } else {
                                ambiguous = true;
                            }
                        }
                    }
                    if (hole_unassigned) {
                        betterShapeHoles[sIdx1].push(ho);
                    }
                }
            }
            if (toChange.length > 0) {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i1 = 0, il = newShapes.length; i1 < il; i1++){
            tmpShape = newShapes[i1].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i1];
            for(let j = 0, jl = tmpHoles.length; j < jl; j++){
                tmpShape.holes.push(tmpHoles[j].h);
            }
        }
        return shapes;
    }
});
function Font(data) {
    this.type = "Font";
    this.data = data;
}
Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text1, size) {
        if (size === undefined) size = 100;
        const shapes = [];
        const paths = createPaths(text1, size, this.data);
        for(let p = 0, pl = paths.length; p < pl; p++){
            Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
    }
});
function createPaths(text1, size, data) {
    const chars = Array.from ? Array.from(text1) : String(text1).split("");
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i = 0; i < chars.length; i++){
        const __char = chars[i];
        if (__char === "\n") {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(__char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(__char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[__char] || data.glyphs["?"];
    if (!glyph) {
        console.error('THREE.Font: character "' + __char + '" does not exists in font family ' + data.familyName + ".");
        return;
    }
    const path = new ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for(let i = 0, l = outline.length; i < l;){
            const action = outline[i++];
            switch(action){
                case "m":
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case "l":
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case "q":
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case "b":
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    cpx2 = outline[i++] * scale + offsetX;
                    cpy2 = outline[i++] * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path
    };
}
function FontLoader(manager) {
    Loader.call(this, manager);
}
FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FontLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text1) {
            let json;
            try {
                json = JSON.parse(text1);
            } catch (e) {
                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
                json = JSON.parse(text1.substring(65, text1.length - 2));
            }
            const font = scope.parse(json);
            if (onLoad) onLoad(font);
        }, onProgress, onError);
    },
    parse: function(json) {
        return new Font(json);
    }
});
let _context;
const AudioContext = {
    getContext: function() {
        if (_context === undefined) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
function AudioLoader(manager) {
    Loader.call(this, manager);
}
AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AudioLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            try {
                const bufferCopy = buffer.slice(0);
                const context = AudioContext.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
});
function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
    }
});
function AmbientLightProbe(color, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
    }
});
const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();
function StereoCamera() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
    };
}
Object.assign(StereoCamera.prototype, {
    update: function(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
});
new Vector3();
new Quaternion();
new Vector3();
new Vector3();
class Audio extends Object3D {
    constructor(listener){
        super();
        this.type = "Audio";
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = "empty";
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay) this.play();
        return this;
    }
    play(delay) {
        if (delay === undefined) delay = 0;
        if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
                this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i = 1, l = this.filters.length; i < l; i++){
                this.filters[i - 1].connect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
            this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i = 1, l = this.filters.length; i < l; i++){
                this.filters[i - 1].disconnect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
            this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else {
            this.filters = value;
        }
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return;
        if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
            this.source.loop = this.loop;
        }
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
}
new Vector3();
new Quaternion();
new Vector3();
new Vector3();
class AudioAnalyser {
    constructor(audio, fftSize){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for(let i = 0; i < data.length; i++){
            value += data[i];
        }
        return value / data.length;
    }
}
function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch(typeName){
        case "quaternion":
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
        default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
    accumulate: function(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            for(let i = 0; i !== stride; ++i){
                buffer[offset + i] = buffer[i];
            }
            currentWeight = weight;
        } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    },
    apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for(let i = stride, e = stride + stride; i !== e; ++i){
            if (buffer[i] !== buffer[i + stride]) {
                binding.setValue(buffer, offset);
                break;
            }
        }
    },
    saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for(let i = stride, e = originalValueOffset; i !== e; ++i){
            buffer[i] = buffer[originalValueOffset + i % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    },
    restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i = startIndex; i < endIndex; i++){
            this.buffer[i] = 0;
        }
    },
    _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i = 0; i < this.valueSize; i++){
            this.buffer[targetIndex + i] = this.buffer[startIndex + i];
        }
    },
    _select: function(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
            for(let i = 0; i !== stride; ++i){
                buffer[dstOffset + i] = buffer[srcOffset + i];
            }
        }
    },
    _slerp: function(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
        const s = 1 - t;
        for(let i = 0; i !== stride; ++i){
            const j = dstOffset + i;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
        }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
        for(let i = 0; i !== stride; ++i){
            const j = dstOffset + i;
            buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
        }
    }
});
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("" + "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = [
    "material",
    "materials",
    "bones"
];
function Composite(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        const bindings = this._bindings;
        for(let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i){
            bindings[i].setValue(array, offset);
        }
    },
    bind: function() {
        const bindings = this._bindings;
        for(let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i){
            bindings[i].bind();
        }
    },
    unbind: function() {
        const bindings = this._bindings;
        for(let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i){
            bindings[i].unbind();
        }
    }
});
function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
    Composite: Composite,
    create: function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
        } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
        }
    },
    sanitizeNodeName: function(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
    },
    parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
    },
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
        }
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) {
                return bone;
            }
        }
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i = 0; i < children.length; i++){
                    const childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                        return childNode;
                    }
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
                return subTreeNode;
            }
        }
        return null;
    }
});
Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for(let i = 0, n = source.length; i !== n; ++i){
                buffer[offset++] = source[i];
            }
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }, 
    ],
    SetterByBindingTypeAndVersioning: [
        [
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }, 
        ],
        [
            function setValue_array(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i = 0, n = dest.length; i !== n; ++i){
                    dest[i] = buffer[offset++];
                }
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i = 0, n = dest.length; i !== n; ++i){
                    dest[i] = buffer[offset++];
                }
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i = 0, n = dest.length; i !== n; ++i){
                    dest[i] = buffer[offset++];
                }
                this.targetObject.matrixWorldNeedsUpdate = true;
            }, 
        ],
        [
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }, 
        ],
        [
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }, 
        ], 
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    bind: function() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch(objectName){
                case "materials":
                    if (!targetObject.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case "bones":
                    if (!targetObject.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return;
                    }
                    targetObject = targetObject.skeleton.bones;
                    for(let i = 0; i < targetObject.length; i++){
                        if (targetObject[i].name === objectIndex) {
                            objectIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) {
            versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            if (propertyName === "morphTargetInfluences") {
                if (!targetObject.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
                        propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                    }
                } else {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else {
            this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
Object.assign(PropertyBinding.prototype, {
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
});
function AnimationObjectGroup() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for(let i = 0, n = arguments.length; i !== n; ++i){
        indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
        objects: {
            get total () {
                return scope._objects.length;
            },
            get inUse () {
                return this.total - scope.nCachedObjects_;
            }
        },
        get bindingsPerObject () {
            return scope._bindings.length;
        }
    };
}
Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i = 0, n = arguments.length; i !== n; ++i){
            const object = arguments[i], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === undefined) {
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                for(let j = 0, m = nBindings; j !== m; ++j){
                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                }
            } else if (index < nCachedObjects) {
                knownObject = objects[index];
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                for(let j1 = 0, m1 = nBindings; j1 !== m1; ++j1){
                    const bindingsForPath = bindings[j1], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) {
                        binding = new PropertyBinding(object, paths[j1], parsedPaths[j1]);
                    }
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) {
                console.error("THREE.AnimationObjectGroup: Different objects with the same UUID " + "detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i = 0, n = arguments.length; i !== n; ++i){
            const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    uncache: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i = 0, n = arguments.length; i !== n; ++i){
            const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    const lastIndex1 = --nObjects, lastObject1 = objects[lastIndex1];
                    indicesByUUID[lastObject1.uuid] = index;
                    objects[index] = lastObject1;
                    objects.pop();
                    for(let j1 = 0, m1 = nBindings; j1 !== m1; ++j1){
                        const bindingsForPath1 = bindings[j1];
                        bindingsForPath1[index] = bindingsForPath1[lastIndex1];
                        bindingsForPath1.pop();
                    }
                }
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    subscribe_: function(path, parsedPath) {
        const indicesByPath = this._bindingsIndicesByPath;
        let index = indicesByPath[path];
        const bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i = nCachedObjects, n = objects.length; i !== n; ++i){
            const object = objects[i];
            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function(path) {
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
});
class AnimationAction {
    constructor(mixer, clip, localRoot, blendMode){
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        this.blendMode = blendMode || clip.blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: 2400,
            endingEnd: 2400
        };
        for(let i = 0; i !== nTracks; ++i){
            const interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
    }
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    setEffectiveWeight(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1.0, startEndRatio, duration);
            this.warp(endStartRatio, 1.0, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    _update(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
                return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case 2501:
                    for(let j = 0, m = interpolants.length; j !== m; ++j){
                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulateAdditive(weight);
                    }
                    break;
                case 2500:
                default:
                    for(let j1 = 0, m1 = interpolants.length; j1 !== m1; ++j1){
                        interpolants[j1].evaluate(clipTime);
                        propertyMixers[j1].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) {
                        this.enabled = false;
                    }
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) {
                        this.paused = true;
                    } else {
                        this.timeScale = timeScale;
                    }
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === 2202;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === 2200) {
            if (loopCount === -1) {
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) {
                    time = duration;
                } else if (time < 0) {
                    time = 0;
                } else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else {
                    this._setEndings(this.repetitions === 0, true, pingPong);
                }
            }
            if (time >= duration || time < 0) {
                const loopDelta = Math.floor(time / duration);
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    if (pending === 1) {
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else {
                        this._setEndings(false, false, pingPong);
                    }
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else {
                this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
                return duration - time;
            }
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            if (atStart) {
                settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
                settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
                settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
                settings.endingEnd = WrapAroundEnding;
            }
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    }
}
function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1.0;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i = 0; i !== nTracks; ++i){
            const track = tracks[i], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) {
                bindings[i] = binding;
            } else {
                binding = bindings[i];
                if (binding !== undefined) {
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for(let i = 0, n = bindings.length; i !== n; ++i){
                const binding = bindings[i];
                if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for(let i = 0, n = bindings.length; i !== n; ++i){
                const binding = bindings[i];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    _initMemoryManager: function() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
            actions: {
                get total () {
                    return scope._actions.length;
                },
                get inUse () {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope._bindings.length;
                },
                get inUse () {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope._controlInterpolants.length;
                },
                get inUse () {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    },
    _isActiveAction: function(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
        const bindings = action._propertyBindings;
        for(let i = 0, n = bindings.length; i !== n; ++i){
            const binding = bindings[i];
            if (--binding.referenceCount === 0) {
                this._removeInactiveBinding(binding);
            }
        }
    },
    _lendAction: function(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    _addInactiveBinding: function(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
        }
    },
    _lendBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    _lendControlInterpolant: function() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === undefined) {
            if (clipObject !== null) {
                blendMode = clipObject.blendMode;
            } else {
                blendMode = NormalAnimationBlendMode;
            }
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode) {
                return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null) {
                clipObject = prototypeAction._clip;
            }
        }
        if (clipObject === null) return null;
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    existingAction: function(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
    },
    stopAllAction: function() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i = nActions - 1; i >= 0; --i){
            actions[i].stop();
        }
        return this;
    },
    update: function(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for(let i = 0; i !== nActions; ++i){
            const action = actions[i];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i1 = 0; i1 !== nBindings; ++i1){
            bindings[i1].apply(accuIndex);
        }
        return this;
    },
    setTime: function(timeInSeconds) {
        this.time = 0;
        for(let i = 0; i < this._actions.length; i++){
            this._actions[i].time = 0;
        }
        return this.update(timeInSeconds);
    },
    getRoot: function() {
        return this._root;
    },
    uncacheClip: function(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            const actionsToRemove = actionsForClip.knownActions;
            for(let i = 0, n = actionsToRemove.length; i !== n; ++i){
                const action = actionsToRemove[i];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    uncacheRoot: function(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) {
            for(const trackName in bindingByName){
                const binding = bindingByName[trackName];
                binding.restoreOriginalState();
                this._removeInactiveBinding(binding);
            }
        }
    },
    uncacheAction: function(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
class Uniform {
    constructor(value){
        if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
        }
        this.value = value;
    }
    clone() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
}
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    clone: function(data) {
        const ib = InterleavedBuffer.prototype.clone.call(this, data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    },
    toJSON: function(data) {
        const json = InterleavedBuffer.prototype.toJSON.call(this, data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(GLBufferAttribute.prototype, {
    isGLBufferAttribute: true,
    setBuffer: function(buffer) {
        this.buffer = buffer;
        return this;
    },
    setType: function(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
    },
    setItemSize: function(itemSize) {
        this.itemSize = itemSize;
        return this;
    },
    setCount: function(count) {
        this.count = count;
        return this;
    }
});
function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
        Mesh: {},
        Line: {
            threshold: 1
        },
        LOD: {},
        Points: {
            threshold: 1
        },
        Sprite: {}
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                return this.Points;
            }
        }
    });
}
function ascSort(a, b) {
    return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
    if (object.layers.test(raycaster.layers)) {
        object.raycast(raycaster, intersects);
    }
    if (recursive === true) {
        const children = object.children;
        for(let i = 0, l = children.length; i < l; i++){
            intersectObject(children[i], raycaster, intersects, true);
        }
    }
}
Object.assign(Raycaster.prototype, {
    set: function(origin, direction) {
        this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else {
            console.error("THREE.Raycaster: Unsupported camera type.");
        }
    },
    intersectObject: function(object, recursive, optionalTarget) {
        const intersects = optionalTarget || [];
        intersectObject(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
        const intersects = optionalTarget || [];
        if (Array.isArray(objects) === false) {
            console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
            return intersects;
        }
        for(let i = 0, l = objects.length; i < l; i++){
            intersectObject(objects[i], this, intersects, recursive);
        }
        intersects.sort(ascSort);
        return intersects;
    }
});
const _vector7 = new Vector2();
class Box2 {
    constructor(min, max){
        Object.defineProperty(this, "isBox2", {
            value: true
        });
        this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i = 0, il = points.length; i < il; i++){
            this.expandByPoint(points[i]);
        }
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector7.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = +Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .getCenter() target is now required");
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .getSize() target is now required");
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .getParameter() target is now required");
            target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .clampPoint() target is now required");
            target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector7.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
const _startP = new Vector3();
const _startEnd = new Vector3();
class Line3 {
    constructor(start, end){
        this.start = start !== undefined ? start : new Vector3();
        this.end = end !== undefined ? end : new Vector3();
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .getCenter() target is now required");
            target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .delta() target is now required");
            target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .at() target is now required");
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) {
            t = MathUtils.clamp(t, 0, 1);
        }
        return t;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn("THREE.Line3: .closestPointToPoint() target is now required");
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
}
function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {};
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
new Vector3();
const _vector8 = new Vector3();
const _boneMatrix = new Matrix4();
const _matrixWorldInv = new Matrix4();
class SkeletonHelper extends LineSegments {
    constructor(object){
        const bones = getBoneList(object);
        const geometry = new BufferGeometry();
        const vertices = [];
        const colors = [];
        const color1 = new Color(0, 0, 1);
        const color2 = new Color(0, 1, 0);
        for(let i = 0; i < bones.length; i++){
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry, material);
        this.type = "SkeletonHelper";
        this.isSkeletonHelper = true;
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute("position");
        _matrixWorldInv.getInverse(this.root.matrixWorld);
        for(let i = 0, j = 0; i < bones.length; i++){
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                _vector8.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j, _vector8.x, _vector8.y, _vector8.z);
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                _vector8.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j + 1, _vector8.x, _vector8.y, _vector8.z);
                j += 2;
            }
        }
        geometry.getAttribute("position").needsUpdate = true;
        super.updateMatrixWorld(force);
    }
}
function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) {
        boneList.push(object);
    }
    for(let i = 0; i < object.children.length; i++){
        boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
}
new Vector3();
new Color();
new Color();
class GridHelper extends LineSegments {
    constructor(size, divisions, color1, color2){
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for(let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step){
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = "GridHelper";
    }
}
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Camera();
new Box3();
new Vector3();
const LOD_MIN = 4;
const LOD_MAX = 8;
const EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const TOTAL_LODS = 8 - 4 + 1 + EXTRA_LOD_SIGMA.length;
new OrthographicCamera();
const { _lodPlanes , _sizeLods , _sigmas  } = _createPlanes();
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
[
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-PHI, INV_PHI, 0), 
];
function _createPlanes() {
    const _lodPlanes = [];
    const _sizeLods = [];
    const _sigmas = [];
    let lod = 8;
    for(let i = 0; i < TOTAL_LODS; i++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods.push(sizeLod);
        let sigma = 1.0 / sizeLod;
        if (i > 8 - 4) {
            sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
        } else if (i == 0) {
            sigma = 0;
        }
        _sigmas.push(sigma);
        const texelSize = 1.0 / (sizeLod - 1);
        const min = -texelSize / 2;
        const max = 1 + texelSize / 2;
        const uv1 = [
            min,
            min,
            max,
            min,
            max,
            max,
            min,
            min,
            max,
            max,
            min,
            max
        ];
        const position = new Float32Array(3 * 6 * 6);
        const uv = new Float32Array(2 * 6 * 6);
        const faceIndex = new Float32Array(1 * 6 * 6);
        for(let face = 0; face < 6; face++){
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x,
                y,
                0,
                x + 2 / 3,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y + 1,
                0, 
            ];
            position.set(coordinates, 3 * 6 * face);
            uv.set(uv1, 2 * 6 * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, 1 * 6 * face);
        }
        const planes = new BufferGeometry();
        planes.setAttribute("position", new BufferAttribute(position, 3));
        planes.setAttribute("uv", new BufferAttribute(uv, 2));
        planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, 1));
        _lodPlanes.push(planes);
        if (lod > 4) {
            lod--;
        }
    }
    return {
        _lodPlanes,
        _sizeLods,
        _sigmas
    };
}
Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
Object.assign(CurvePath.prototype, {
    createPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const pts = this.getPoints(divisions);
        return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
    },
    createGeometry: function(points) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const geometry = new Geometry();
        for(let i = 0, l = points.length; i < l; i++){
            const point = points[i];
            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
    }
});
Object.assign(Path.prototype, {
    fromPoints: function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
    }
});
function ClosedSplineCurve3(points) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
    this.closed = true;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
function SplineCurve3(points) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
function Spline(points) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
    initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    }
});
GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
    }
});
Loader.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
};
Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    size: function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    }
});
Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    isIntersectionSphere: function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    }
});
Object.assign(Sphere.prototype, {
    empty: function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    }
});
Frustum.prototype.setFromMatrix = function(m) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
};
Object.assign(MathUtils, {
    random16: function() {
        console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
        return Math.random();
    },
    nearestPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
        return MathUtils.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
        return MathUtils.ceilPowerOfTwo(value);
    }
});
Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBufferAttribute: function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
});
Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    getPosition: function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
    },
    multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
    },
    crossVector: function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBufferAttribute: function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
    }
});
Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
    isIntersectionBox: function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    isIntersectionPlane: function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Triangle.prototype, {
    area: function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
    },
    normal: function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
    },
    plane: function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
    }
});
Object.assign(Triangle, {
    barycoordFromPoint: function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
    }
});
Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
    },
    extrude: function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
    }
});
Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function(m) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
Object.assign(Geometry.prototype, {
    computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    },
    applyMatrix: function(matrix) {
        console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
    }
});
Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
    },
    renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    },
    translate: function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    },
    applyMatrix: function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
        },
        set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
    }
});
Object.assign(Mesh.prototype, {
    setDrawMode: function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
});
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return 0;
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
    }
});
Object.defineProperties(LOD.prototype, {
    objects: {
        get: function() {
            console.warn("THREE.LOD: .objects has been renamed to .levels.");
            return this.levels;
        }
    }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
    get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
    get: function() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions;
    },
    set: function(value) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = value;
    }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        }
    },
    shadowCameraFov: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
    },
    shadowBias: {
        set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
    },
    shadowMapWidth: {
        set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
        }
    }
});
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
        }
    },
    dynamic: {
        get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === 35048;
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(35048);
        }
    }
});
Object.assign(BufferAttribute.prototype, {
    setDynamic: function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? 35048 : 35044);
        return this;
    },
    copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    },
    setArray: function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }
});
Object.assign(BufferGeometry.prototype, {
    addIndex: function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
    },
    addAttribute: function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
            console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
            return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
            console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
            this.setIndex(attribute);
            return this;
        }
        return this.setAttribute(name, attribute);
    },
    addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== undefined) {
            console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
    },
    clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
    },
    computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    },
    computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    },
    removeAttribute: function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
    },
    applyMatrix: function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
        }
    }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
    maxInstancedCount: {
        get: function() {
            console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
            return this.instanceCount;
        },
        set: function(value) {
            console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
            this.instanceCount = value;
        }
    }
});
Object.defineProperties(Raycaster.prototype, {
    linePrecision: {
        get: function() {
            console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
            return this.params.Line.threshold;
        },
        set: function(value) {
            console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
            this.params.Line.threshold = value;
        }
    }
});
Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
        get: function() {
            console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
            return this.usage === 35048;
        },
        set: function(value) {
            console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
            this.setUsage(value);
        }
    }
});
Object.assign(InterleavedBuffer.prototype, {
    setDynamic: function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? 35048 : 35044);
        return this;
    },
    setArray: function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }
});
Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    },
    addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    },
    addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    }
});
Object.assign(Scene.prototype, {
    dispose: function() {
        console.error("THREE.Scene: .dispose() has been removed.");
    }
});
Object.defineProperties(Uniform.prototype, {
    dynamic: {
        set: function() {
            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        }
    },
    onUpdate: {
        value: function() {
            console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
            return this;
        }
    }
});
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        }
    },
    wrapRGB: {
        get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
        }
    },
    stencilMask: {
        get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
        },
        set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
        }
    }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
            return false;
        },
        set: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
    }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
    transparency: {
        get: function() {
            console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
            return this.transmission;
        },
        set: function(value) {
            console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
            this.transmission = value;
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
        },
        set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
        }
    }
});
Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    },
    animate: function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
    },
    resetGLState: function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
    },
    supportsFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(__boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(__boolean);
    },
    initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    },
    setTexture: function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    },
    getActiveMipMapLevel: function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
    }
});
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    context: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
        }
    },
    vr: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
        }
    },
    gammaInput: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
    },
    gammaOutput: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1.0;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
    }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
        }
    },
    wrapT: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
        }
    },
    magFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
        }
    },
    minFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
        }
    },
    anisotropy: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
        }
    },
    offset: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
        }
    },
    repeat: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
        }
    },
    format: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
        }
    },
    type: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
        }
    }
});
Object.defineProperties(Audio.prototype, {
    load: {
        value: function(file) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const scope = this;
            const audioLoader = new AudioLoader();
            audioLoader.load(file, function(buffer) {
                scope.setBuffer(buffer);
            });
            return this;
        }
    },
    startTime: {
        set: function() {
            console.warn("THREE.Audio: .startTime is now .play( delay ).");
        }
    }
});
AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer, scene);
};
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: REVISION
        }
    }));
}
function main() {
    const scene = new Scene();
    const group1 = new Group();
    const group2 = new Group();
    const group3 = new Group();
    scene.add(group1);
    scene.add(group2);
    scene.add(group3);
    const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 0, 100);
    camera.lookAt(0, 0, 0);
    scene.fog = new Fog(0xfffff0, 10, 2000);
    scene.background = new Color(0xffffff);
    const renderer = new WebGLRenderer({
        antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const light = new AmbientLight(0xffffff, 1);
    const light2 = new DirectionalLight(0xffffff, 1);
    scene.add(light);
    scene.add(light2);
    for(let i = 0; i < 500; i++){
        group1.add(makeCylinder(-1000, -1500));
    }
    for(let i1 = 0; i1 < 1000; i1++){
        group2.add(makeCylinder(-1500, -2000));
    }
    for(let i2 = 0; i2 < 3000; i2++){
        group3.add(makeCylinder(-2000, -2500));
    }
    let textPopUpStatus = false;
    const loader = new FontLoader();
    let g1status, g2status, g3status = true;
    function animate() {
        requestAnimationFrame(animate);
        if (group1.position.z > 1500 && g1status) {
            for(let i = group1.children.length - 1; i >= 0; --i){
                group1.remove(group1.children[i]);
            }
            g1status = false;
        }
        if (group2.position.z > 2000 && g2status) {
            for(let i1 = group2.children.length - 1; i1 >= 0; --i1){
                group2.remove(group2.children[i1]);
            }
            g2status = false;
        }
        if (group3.position.z > 2600 && g3status) {
            for(let i2 = group3.children.length - 1; i2 >= 0; --i2){
                group3.remove(group3.children[i2]);
            }
            g3status = false;
            textPopUpStatus = true;
        }
        if (textPopUpStatus) {
            loader.load("../../assets/gentilis_bold.typeface.json", (font)=>{
                text = new Mesh(makeTextGeometry(font), makeTextMatrial());
                scene.add(text);
            });
            textPopUpStatus = false;
        }
        group1.position.z += 15;
        group2.position.z += 15;
        group3.position.z += 15;
        renderer.render(scene, camera);
    }
    animate();
}
function degToRad(deg) {
    return Math.PI / 180 * deg;
}
function makeCylinder(maxzpos, minzpos) {
    const geometry = new CylinderGeometry(2, 2, 40);
    const material = new MeshBasicMaterial({
        color: `rgb(${Math.ceil(Math.random() * 255)}, ${Math.ceil(Math.random() * 255)},${Math.ceil(Math.random() * 255)})`
    });
    const cylinder = new Mesh(geometry, material);
    const r = Math.random() * (200 - 10) + 10;
    const theta = Math.random() * 360;
    cylinder.position.x = r * Math.cos(degToRad(theta));
    cylinder.position.y = r * Math.sin(degToRad(theta));
    cylinder.position.z = Math.random() * (maxzpos - minzpos) + minzpos;
    cylinder.rotation.x = degToRad(90);
    return cylinder;
}
function makeTextGeometry(font) {
    const textGeometry = new TextGeometry("Welcome to\nIovesophy's world", {
        font: font,
        size: window.innerWidth / 200,
        height: 1,
        curveSegments: 5
    });
    textGeometry.center();
    return textGeometry;
}
function makeTextMatrial() {
    return new MeshToonMaterial({
        color: "rgb(0 ,255 ,200)"
    });
}
main();
